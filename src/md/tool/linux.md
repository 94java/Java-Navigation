---
title: "Linux"
order: 2
category:
  - 工具 | 部署
---

# Linux

### 初识Linux

**操作系统**：管理==计算机硬件==与==软件资源==的计算机程序，同时也是计算机系统的内核与基石。

**主流操作系统**

- 桌面操作系统：Window系列、macOS、Linux
- 服务器操作系统：Linux、Windows Server
- 嵌入式操作系统：Linux
- 移动设备操作系统：Unix（Linux、ios）

**Linux发展历程**

- 1984年Minix（只用于教学）
- 1991年编写驱动程序，年底公开Linux内核源码
- 1994年Linux1.0（Linus Torvalds）
- 至此开始流行起来

**Linux特点**

- Linux是一套==免费==使用和自由传播的类Unix操作系统

- 是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统
- 它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件
- 继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统
- 两个基本思想
  - 一切都是文件
  - 每个软件都有确定的用途
- 完全兼容POSIX1.0标准
- 多用户、多任务
- 良好的界面
- 支持多种平台

**Linux与其它操作系统的区别**

- 开源情况
- 硬件适用
- 本质不同
- 系统界面
- 驱动程序
- 系统使用
- 软件与支持

> Windows更适用于家庭个人使用
>
> Linux更适用于企业服务器使用

**Linux发行商和常见发行版**

- Redhat公司--------Red Hat Linux（最著名的Linux版本、收费）-----免费的CentOS
- CentOS特点：主流、免费、更新方便

### Linux的安装和使用

先安装虚拟机，再安装Centos

#### Vmware

**Vmware简介**

- 不需要分区或者重开机就能在同一台PC上使用两种以上的操作系统
- 完全隔离并且保护不同操作系统的环境以及所有的软件、资料
- 不同的操作系统之间还可以进行互动操作
- 有复原功能
- 能够设置并且随时修改操作系统的操作环境
- 常见虚拟机软件：VMware workstation、VirtualBox

**Vmware下载**：https://www.vmware.com/cn.html

**CentOS镜像下载**：https://www.centos.org/download/
==高速下载地址==

- http://mirrors.aliyun.com
- http://mirrors.sohu.com
- http://mirrors.163.com
- http://mirrors.cqu.edu.cn/CentOS

#### SecureCRT

简介：SecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录Unix或Linux服务器主机的软件。

#### 目录和文件

- Linux没有盘符这个概念，只有一个根目录/，所有文件都在他下面
- etc表示系统中的配置文件
- usr、usr/bin、usr/sbin都表示系统预设执行文件的放置目录
- var/log表示程序运行日志的存放目录
- 切换根目录：`cd /`
- 查看目录内容：`ls -l`

#### 时间同步

![](E:\Typora\学习笔记\images\时间同步.png)

#### 克隆与快照

**克隆**：将原系统完完全全的拷贝一份，原系统丢失后克隆的系统还能正常使用

- 占用空间大
- 原系统不存在，克隆体还能用

**快照**：记录系统当前状态，并不会把系统完整拷贝

- 占用空间小
- 原系统不存在，快照也就无法使用

> 克隆和拍摄快照时都需要关闭虚拟机

### 系统与设置命令

#### 账号管理

> 与用户相关的命令，必须在管理员权限下才能执行
>
> 命令：`su root`

- 创建用户：`useradd (选项) 用户名`
- 用户口令：`passwd (选项) 用户名`
  - 密码不能是一个回文
  - 长度必须大于8位
  - 必须是字母和数字的结合

> 在root权限下切换其它用户可直接切换，无需输入密码

- 修改用户：`usermod 选项 用户名`

![](E:\Typora\学习笔记\images\修改用户.png)

- 删除用户：`userdel (选项) 用户名`

![](E:\Typora\学习笔记\images\用户删除.png)

#### 用户组

将用户分成小组，方便对用户的管理

- 创建用户组：`groupadd (选项) 用户组名`

- 修改用户组：`groupmod (选项) 用户组名`
  ![](E:\Typora\学习笔记\images\修改用户组.png)

- 查询用户所属组：`groups 用户名`

- 删除用户组：`groupdel 用户组名`

- 管理用户组内成员：`gpasswd (可选项) 组名`

  > gpasswd是Linux下的管理工具，用于将一个用户添加到组或者从组中删除

  - -a：添加用户到组
  - -d：从组中删除用户
  - -A：指定管理员
  - -M：指定组员和-A的用途差不多
  - -r：删除密码
  - -R：限制用户登入组，只有组中的成员才可以用newgrp加入该组

![](E:\Typora\学习笔记\images\用户添加到组.png)

#### 系统管理相关命令

- 日期管理：`date [参数选项]`

  参数选项：

  - `-d "字符串"`：显示字符串所指的日期与时间。字符串前后必须加上双引号
  - `-s "字符串"`：根据字符串来设置日期与时间。字符串前后必须加上双引号
  - `-u`：显示GMT（北京时间为CST）
  - `--help`：在线帮助
  - `--version`：显示版本信息

- 显示登陆账号的信息：`logname`

- 切换用户：`su 用户名`

- 查看当前用户详细信息（用户id、群组id、所属组）：`id 用户名`

- 提高普通用户的操作权限：`sudo [参数选项]`

#### 进程相关命令

- 实时显示process的动态：`top`

  > pid:每个进程的id
  >
  > user：进程是属于哪个用户
  >
  > PR：进程的优先级
  >
  > NI：进程优先级（负数为高优先级，正数为低优先级）
  >
  > VIRT：当前进程占用虚拟内存的总量
  >
  > S：当前进程的状态

  - 实时显示所有进程信息（显示完整命令）:`top -c`
  - 实时显示指定进程的信息：`top -p PID`
  - 结束实时监控：`q`

- 查看当前正在运行的进程信息：`ps`
  - 显示系统中所有的进程信息：`ps -A`
  - 显示系统中所有的进程信息（完整信息）：`ps -ef`
  - 显示指定用户的进程信息：`ps -u 用户名`
  
- 中断执行中的程序：`kill PID`
  - 例如：`kill 1111`表示杀死PID为1111的进程
  - `kill -9 PID`：强制杀死指定PID的进程
  - `killall -u 用户名`：杀死这个用户中的所有进程
  - `kill -9 $(ps -ef|grep 用户名)`：杀死指定用户的所有进程
  - `kill -l`：查看对应编号
  
- 关机命令：`shutdown`（延迟关机）

  - `shutdown -h now`：立即关机
  - `shutdown +1 "1分钟以后关机"`：延迟一分钟以后关机，并给出警告信息
  - `shutdown -r +1 "准备重启了"`：延迟一分钟以后重启，并给出警告信息
  - `shutdown -c`：取消关机命令

- 重启命令：`reboot`（立即重启）

- 显示当前登录系统的用户：`who`

  - `who -H`：显示明细（标题）信息

- 校正服务器时间、时区：`timedatectl`

  - 几个小概念

    | 项目                          | 说明                                                         |
    | ----------------------------- | ------------------------------------------------------------ |
    | 时区                          | 因时区不同显示的时间不同，牵扯到夏令时和调整等问题，date命令可查看 |
    | 系统时钟：System Clock        | Linux OS的时间，date命令可查看                               |
    | 硬件时钟：RTC:Real Time Clock | 主板上由电池供电的BIOS时间，hwclock -r可查看                 |
    | NTP:Network Time Protocol     | 本机时间和实际的时间之间的经常会有差别，一般使用NTP服务器进行时间校准 |

  - `timedatectl status`：显示系统的当前时间和日期
  - `timedatectl list-timezones`：查看所有可用的时区
  - `timedatectl set-timezone "Asia/Shanghai"`：设置本地时区
  - `timedatectl set-ntp false`：禁用时间同步
  - `timedatectl set-time "2022-02-22 20:20:00"`：设置时间
  - `timedatectl set-ntp true`：启用时间同步

- 清除屏幕：`clear`

#### 目录管理

| 常见命令 | 作用                                       |
| -------- | ------------------------------------------ |
| ls       | 列出目录                                   |
| cd       | 切换目录                                   |
| pwd      | 显示目前的目录                             |
| mkdir    | 创建新目录                                 |
| rmdir    | 删除空目录                                 |
| cp       | 复制文件或目录                             |
| rm       | 删除文件或目录                             |
| mv       | 移动文件或目录<br />修改文件或者目录的名字 |

- ls命令相当于在Windows系统中打开文件夹，看到的目录以及文件的明细。

  - 语法：`ls [参数选项] 目录名称`
  - `-a`：显示所有文件或目录（包含隐藏）
  - `-d`：仅列出目录本身，而不是列出目录内的文件数据（常用）
  - `-l`：长数据串列出，包含文件的属性与权限等等数据（常用）

  > `ls`：显示不隐藏的文件与文件夹
  > `ls -l`：显示不隐藏的文件与文件夹的详细信息
  > `ls -al`：显示所有文件与文件夹的详细信息

- `pwd -P`：查看当前所在目录
- `cd [相对路径或绝对路径]`：切换目录
  
  - `cd ..`：返回上一级目录

- `mkdir`
  - `mkdir 文件夹的名字`：创建单级目录
  - 创建多级文件夹，使用`mkdir -p aaa/bbb`

- `rmdir`

  - `rmdir 文件夹名字`：删除空目录
  - `rmdir -p aaa/bbb`：删除多级目录（先删bbb，如果删完aaa也为空，则aaa也一起删除）

- `rm`

  - `rm 文件路径`：删除文件

  - `rm -r 目录路径`：删除目录和目录里面所有的内容（单级目录或多级目录都行）

- `touch 文件名.后缀名`：创建一个文件

- `cp`

  - `cp 数据源 目的地`：文件复制（仅文件）
  - `cp -r aaa/* ccc`：将aaa目录中的所有文件及目录拷贝到ccc中（`*`代指所有）

- `mv`

  - `mv 数据源 目的地`：改名(数据源和目的地相同)、移动文件或文件夹
  - `mv 文件名 文件名`：将源文件名改为目标文件名
  - `mv 目录名 目录名`：目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名

#### 文件基本属性

- 文件权限（共10位）

  - 第一位为==d==表示是一个文件夹；是==-==表示是一个文件；==|==表示是一个链接文档（快捷方式）
  - ==r==表示可读；==w==表示可写；==x==表示可执行；==-==表示没有当前权限
  - 2-4位表示属主权限（文件所属的用户可以做的事情）
  - 5-7位表示属组权限（文件所在用户组可以对它做的事）
  - 8-10位表示其它用户权限

- `chgrp`命令（change group）

  - `chgrp [选项参数] [所属群组] [文件或目录...]`：更改所属组
  - `chgrp root aaa`：将aaa文件夹所属组更改为root
  - `chgrp -v root aaa`：将aaa的属组改为root（==-v==会多一句提示语）

- `chown`命令

  - `chown 属主名 文件名`：更改属主
  - `chown [参数选项] 属主名:属组名 文件名`：更改属主和属组
  - ==-R==：处理指定目录以及其子目录下的所有文件

- `chmod`命令

  - 作用：修改属主、属组、其他用户的权限
  - 数字方式语法：`chmod [参数选项] 数字权限 文件或目录`
  - 符号方式语法：`chmod u=rwx,g=rx,o=r a.txt`
  - ==-R==：对目前目录下的所有档案与子目录进行相同的权限变更（即以递回的方式逐个变更）
  
  修改方式：
  
  - 数字方式
  
    - ==r==-----==4==
    - ==w==----==2==
    - ==x==----==1==
    - ==-==----==0==
  
    > 设置时会把三个数字加在一起设置
    > 例如：rwx则为7
  
  - 符号方式
  
    - ==user==属主权限----==u==
    - ==group==属组权限----==g==
    - ==others==其它权限----==o==
    - ==all==全部身份----==a==
  
    - ==+==（加入）、==-==（除去）、=====（设定）
    - ==r==（可读）、==w==（可写）、==x==（可执行）

#### 综合案例

> 需求：一个公司的开发团队有三个用户：Java、erlang、golang
> 有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限

**思路**

- 创建三个用户，并把他们加入到对应的用户组（dev-group）
- 将tmp/work文件夹所属组更改为dev-group
- 修改文件夹所属组的权限

![](E:\Typora\学习笔记\images\权限案例.png)

### 文件管理

#### touch

- 语法：`touch [参数选项] 文件名`

  > 如果文件不存在就创建文件，如果存在就修改时间属性

- `touch a{1..10}.txt`：创建a1.txt一直到a10.txt共10个文件（批量创建空文件）
- `stat a.txt`：查看文件的详细信息

#### vi/vim编辑器

- vi编辑器：只能是编辑文本内容，不能对字体、段落进行排版
  - 不支持鼠标操作
  - 没有菜单
  - 只有命令
- vim编辑器：vim是从vi发展出来的一个文本编辑器。
  - 代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用

> 简单来说：
> 	vi是老式的文字处理器，不过功能已经很齐全了，但是还是有可以改进的地方
> 	vim则可以说是程序员开发者的一项很好用的工具

- vi/vim三种模式

  - 阅读模式（命令模式）
  - 编辑模式（编辑模式）
  - 保存模式（末行模式）

  > 命令模式下只能读不能写
  > 在命令模式下输入`i`可以进入编辑模式，在编辑完成之后按下`Esc`又可以退出到命令模式
  > 在命令模式下输入`:`可以进入末行模式，在保存完之后还可以按下两次`Esc`继续回退到命令模式

- 打开和新建文件
  - 语法：`vim 文件名`
  - 如果文件已经存在，会直接打开文件（命令模式）
  - 如果文件不存在，打开一个临时文件，在保存且退出后，就会新建一个文件
- 进入编辑模式

| 命令 | 英文   | 功能                   | 常用   |
| ---- | ------ | ---------------------- | ------ |
| i    | insert | 在当前字符前插入文本   | 常用   |
| I    | insert | 在行首插入文本         | 较常用 |
| a    | append | 在当前字符后添加文本   |        |
| A    | append | 在行末添加文本         | 较常用 |
| o    |        | 在当前行后面插入一空行 | 常用   |
| O    |        | 在当前行前面插入一空行 | 常用   |

- 进入末行模式保存文件

  - `:q`：当vim进入文件没有对文件内容做任何操作可以按“q”退出
  - `:q!`：当vim进入文件对文件内容有操作但不想保存退出
  - `:wq`：正常保存退出
  - `:wq!`：强行保存退出，只针对于root用户或文件所有人

- vim定位行

  - 语法：`vim 文件名 +行数`：查看文件并定位到具体行数
  - `vim a.txt +5`：查看a.txt文件并定位到第5行

- 异常处理

  - 如果vim异常退出，在磁盘上可能会保存有==交换文件==

  > 在修改一个文件时(a.txt)，为保证文件安全，vim不会对源文件进行修改，会产生一个新的文件(a.txt.swp)，并对该文件进行编辑
  > 只有在保存的时候，才会将新文件写回到源文件中
  
  - 如果有交换文件，在下次使用vim编辑文件时，系统会提示是否对交换文件继续操作（将交换文件删除即可）

#### 文件查看

| 命令               | 功能                       |
| ------------------ | -------------------------- |
| cat 文件名         | 查看小文件内容             |
| less -N 文件名     | 分屏显示大文件内容         |
| head -n 文件名     | 查看文件的前一部分         |
| tail -n 文件名     | 查看文件的最后部分         |
| grep 关键字 文件名 | 根据关键字搜索文本文件内容 |

- `cat -n a.txt`：可以加入参数选项`-n`显示行号
  - 只能阅读小文件
  - 阅读大文件可能显示不完整
- `less 文件名`：查看大文件
  - 加入`-N`可显示行号
  - ctrl + F ：向前移动一屏
  - ctrl + B ：向后移动一屏
  - ctrl + D ：向前移动半屏
  - ctrl + U ：向后移动半屏
  - j ：向前移动一行
  - k ：向后移动一行
  - G：移动到最后一行
  - g：移动到第一行
  - q/ZZ：退出less命令
- `tail 文件名`：默认查看文件最后10行内容
  - `tail -3 b.txt`：查看文件最后3行内容
  - `tail -f b.txt`：动态显示文件最后10行内容（==ctrl + C停止==）
  - `tail -n +2 b.txt`：显示文件b.txt的内容，从第2行至文件末尾
  - `tail -c 45 b.txt`：显示文件最后45个字符
- `head 文件名`：查看文件前10行内容
  - 其它内容和tail类似
- `grep命令`
  - 类似于Windows下打开文件后ctrl+F的查找功能
  - 查找对应的进程
  - 语法：`grep [参数选项] 关键字 文件`：根据关键字，搜索文本文件内容
  - ==-n==：把包含关键字的行号展示出来
  - ==-i==：把包含关键字的行展示出来，搜索时忽略大小写
  - ==-v==：把不包含关键字的行展示出来
  - `ps -ef | grep sshd`：将进程中含有sshd的进程展示出来
  - `ps -ef | grep -c sshd`：将进程中含有sshd的进程的个数展示出来

#### echo命令

- `echo 字符串`：展示文本
- `echo 字符串 > 文件名`：将字符串写到文件中（覆盖文件内容）
- `echo 字符串 >> 文件名`：将字符串写到文件中（不覆盖原内容）
- `cat 不存在的目录 &>> 存在的文件`：将命令的失败结果追加到指定的文件的后面

#### awk命令

- AWK是一种处理文本文件的语言，是一个强大的文本分析工具（名字取自三位创始人名字中的字母）
- 语法：`awk [参数选项] '语法' 文件`
- 过滤：`cat a.txt | awk '/zhang|li/'`：查看a.txt文件中包含zhang或者li的行
- 切割

| 选项         | 含义                     |
| ------------ | ------------------------ |
| `-F ','`     | 使用指定字符分割         |
| `$ + 数字`   | 获取第几段内容           |
| `$0`         | 获取当前行内容           |
| `OFS="字符"` | 向外输出时的段分割字符串 |
| `toupper()`  | 字符转成大写             |
| `tolower()`  | 字符转成小写             |
| `length()`   | 返回字符长度             |

> `cat a.txt | awk -F ' ' '{print $1,$2,$3}'`：将a.txt中的内容按空格分割并打印第1-3列
> `cat a.txt | awk -F ' ' '{print toupper($1),$2,$3}'`：将a.txt中的内容分隔后并将$1中的内容转为大写字符后输出
> `cat a.txt | awk -F '' '{OFS="---"}{print $1,$2,$3}'`：将a.txt中的内容分隔后并用---重新分隔后输出

- 计算

| 命令                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| awk<br />BEGIN{初始化操作}<br />{每行都执行}<br />END{结束时操作}<br />文件名 | 固定语法<br />BEGIN{这里面放的是执行前的语句}<br />{这里面放的是处理每一行要执行的语句}<br />END{这里面放的是处理完所有的行后要执行的语句}<br />文件名 |

> `cat a.txt | awk -F' ' 'BEGIN{}{totle=totle+$2}END{print totle}'`：将a.txt分割后把$2的值相加并输出
> `cat a.txt | awk -F' ' 'BEGIN{}{totle=totle+$2}END{print totle}'`：输出totle以及总人数（行数）

#### 软连接

- 类似于Windows里面的快捷方式
- 语法：`ln -s 目标文件路径 快捷方式路径`
- `ln -s aaa/bbb/ccc/ddd/eee/a.txt a.txt`

### 压缩命令

#### 查找命令

- 语法：`find [参数选项] <指定目录> <指定条件> <指定内容>`：在指定目录下查找文件

- 参数选项

  - ==-name filename==：查找名为filename的文件
  - ==-ctime -n或+n==：按时间来查找文件，-n指n天以内，+n指n天以前

- `find . -name "*.txt"`：查找当前目录下所有以txt为后缀的文件

- `find . -ctime -1`：当前文件夹下1天内操作过的文件

  > 将==.==替换为==/==则表示在全盘范围进行查找

#### gzip命令

- 语法：`gzip [参数选项] [文件]`：压缩文件
- `gzip a.txt`：将a.txt文件压缩
- `gzip *`：将当前目录下所有文件都进行压缩（已经压缩过的不能再次被压缩）
- `gzip -dv 文件名`：解压文件并显示详细信息

#### gunzip命令

- 语法：`gunzip [参数] [文件]`：解压文件
- `gunzip 压缩文件`：解压压缩文件
- `gunzip *`：解压当前目录下的所有压缩文件

#### tar命令

- 语法：`tar [必要参数] [选择参数] [文件]`：打包、压缩和解压（文件/文件夹）
- ==注意==：tar本身不具有压缩功能，它是调用压缩功能实现的
- 参数选项
  - ==-c==：建立新的压缩文件
  - ==-v==：显示指令执行过程
  - ==-f <备份文件>==：指定压缩文件
  - ==-z==：通过gzip指令处理压缩文件
  - ==-t==：列出压缩文件中的内容
  - ==-x==：表示解压
- `tar -cvf 打包文件名 文件名`：打包文件并指定打包之后的文件名（仅打包不压缩）
- `tar -zcvf b.gz b.txt`：通过gzip指令将b.txt压缩为b.gz并显示过程（打包压缩）
- `tar -zcvf aaa.gz aaa`：将aaa文件夹压缩为aaa.gz
- `tar -ztvf aaa.gz`：查看压缩文件中的内容
- `tar -zxvf aaa.gz`：解压aaa.gz文件

#### zip命令

- 语法：`zip [必要参数] [选择参数] [文件]`：压缩
- ==注意==：zip是个使用广泛的压缩程序，文件经他压缩后会另外产生具有"==.zip=="扩展名的压缩文件
- 参数选项
  - ==-q==：不显示指令执行过程
  - ==-r==：递归处理，将指定目录下的所有文件和子目录一并处理
- `zip -q -r 压缩文件名 文件/文件夹`：压缩对应的文件/文件夹

#### unzip命令

- 语法：`unzip [必要参数] [选择参数] [文件]`：解压
- ==注意==：只能解压"==.zip=="扩展名的压缩文件
- 参数选项
  - ==-l==：显示压缩文件内所包含的文件
  - ==-d <目录>==：指定文件解压缩后要存储的目录
- `unzip -l aaa.zip`：查看aaa.zip压缩文件所包含的文件
- `unzip -d aaa aaa.zip`：将aaa.zip压缩文件解压到aaa文件夹中（aaa文件夹可以不存在，会自动创建）

#### bzip2命令

- 语法：`bzip2 [参数选项] 文件`：压缩文件
- ==注意==：使用新的压缩算法，和zip相比压缩后的==文件比原来的要小==，但==花费时间变长==
- 若没有加上任何参数，bizp2压缩完文件后会产生bz2的压缩文件，并删除原始文件
- `bzip2 a.txt`：压缩并删除a.txt
- **bunzip2命令**：`bunzip2 [参数选项] 文件`：解压
  - ==-v==：解压文件时，显示详细的信息
  - `bunzip2 -v a.bz2`：解压并显示详细信息

### 网络与磁盘管理

#### 网络管理

- **ifconfig命令**
  - 语法：`ifconfig [参数选项]`：显示或配置网络设备的命令
  - `ifconfig ens37 down`：关闭ens37这张网卡
  - `ifconfig ens37 up`：开启网卡ens37
  - `ifconfig ens37 192.168.23.199`：将ens37网卡的ip更改为192.168.23.199
  - `ifconfig ens37 192.168.23.199 netmask 255.255.255.0`：配置ip地址和子网掩码
- **ping命令**
  - 语法：`ping [参数选项]`：检测是否与主机联通
  - ==-c <完成次数>==：设置完成要求回应的次数
  - `ping -c 2 www.baidu.com`：指定接收包的次数
- **netstat命令**
  - 语法：`netstat [参数选项]`：显示网络状态
  - ==-a==：显示所有连线中的Socket
  - ==-i==：显示网卡列表

#### 磁盘管理

- **lsblk命令**

  - 语法：`lsblk [参数选项]`：列出硬盘的使用情况
  - 理解为：list block的英文缩写
  - `lsblk -f`：显示系统信息

- **df命令**

  - 语法：`df [参数选项]`：显示目前在Linux系统上，磁盘的使用情况
  - ==--total==：显示所有的信息
  - ==-h==：换算成KB，MB，GB等形式进行展示（方便阅读）
  - `df`：显示整个硬盘的使用情况
  - `df 文件夹`：显示文件夹使用情况
  - `df --total`：显示所有的信息
  - `df -h`：将结果变成kb、mb、gb等形式展示，利于阅读

- **mount命令**

  - 语法：`mount [参数选项] 目录`：用于==挂载==Linux系统外的设备
  - 类似与Windows中的U盘，但在Linux中需要手动新建一个文件夹，并把该文件夹和U盘关联起来（挂载点和挂载）

  > 注意：“挂载点”的目录需要以下几个要求：
  > 目录事先存在，可以用mkdir命令新建目录
  > 挂载点目录不可被其它进程使用到
  > 挂载点下原有文件将被隐藏

  - `mount -t auto /dev/cdrom PPP`：将光驱和PPP文件夹挂载
  - `umount PPP`：卸载PPP文件夹所挂载的光驱

#### yum

- 在Linux中，如果我们需要查找、安装、下载或者卸载另外的软件，就需要通过yum来进行操作。英文全称为：Yellow dog Updater,Modified
- **yum常用命令**
  - 列出所有可更新的软件清单命令：`yum check -update`
  - 更新所有软件命令：`yum update`
  - 仅安装指定的软件命令：`yum install <package_name>`
  - 仅更新指定的软件命令：`yum update <package_name>`
  - 列出所有可安装的软件清单命令：`yum list`
  - 删除软件包命令：`yum remove <package_name>`
  - 查找软件包命令：`yum search <keyword>`
  - 清除缓存命令：
    - `yum clean packages`：清除缓存目录下的软件包
    - `yum clean headers`：清除缓存目录下的headers
    - `yum clean oldheaders`：清除缓存目录下旧的headers
    - `yum clean,yum clean all(= yum clean packages;yum clean oldheades)`：清除缓存目录下的软件包及旧的headers
- ==-y==：在安装过程中，如果有选择提示，全部选择==y==
- ==注意==：使用yum必须联网且在root权限下
- `yum -y install tree`：安装tree
- `tree`：执行tree，展示当前目录结构
- `yum remove tree`：移除tree
- `yum list tom*`：查找以tom为开头的软件名称
- **yum源**
  - 在下载软件的时候，都是从yum源中获取的，默认是centos中默认的yum源（在国外，下载速度慢）
  - ==更换国内yum源==
    - `yum -y install wget`：安装一个下载工具
    - `cd /etc/yum.repos.d/`：进入yum的相关文件夹中
    - `mv CentOS-Base.repo CentOS-Base.repo.back`：对原yum文件改名（备份）
    - `wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo`：下载阿里yum源文件
    - `yum clean all`：清理缓存，并重新加载yum
    - `yum makecache`：为新yum源建立缓存文件
    - `yum search tomcat`：查找软件，验证阿里云的yum源是否可以正常使用

#### rpm

- 在最初，RedHat Linux发行版专门用来管理Linux各种套件的程序
- 和yum的区别
  - rpm只能安装已经下载到本地机器上的rpm包
  - yum能在线下载并安装rpm包，能更新系统，且还能自动处理包与包之间的依赖问题，这个是rpm工具所不具备的

### shell

#### 初识shell

> 在计算机科学中，shell就是一个==命令解释器==
> shell是位于操作系统和应用程序之间，是他们二者最主要的接口。
> shell负责把应用程序的输入命令信息解释给操作系统，将操作系统指令处理后的结果解释给应用程序

**一句话，shell就是在操作系统和应用程序之间的一个命令翻译工具。**



**Windows和Linux中的shell**

- Windows系统：cmd.exe		命令提示字符
- Linux系统：sh / csh / ksh / ==bash==(默认) / ...

**shell的使用方式**

- 手工方式

> 手工敲击键盘，直接输入命令，按Enter后。
> 执行命令，显示命令执行的结果
> ==重点==：逐行输入命令，逐行进行确认执行

- 脚本方式

> 我们把手工执行的命令，写到一个文件中，然后运行这个文件，达到执行命令的效果。
> 这个文件就叫做==脚本文件==

**编写第一个shell脚本**

- 新建一个文件后缀名为sh

- 编写内容

  ```shell
  #! /bin/bash
  #这是临时shell脚本
  echo 'nihao'
  echo 'hello'
  ```

- 执行

#### 注释和变量

**注释**

- 单行注释

```shell
#!/bin/bash
# 这是单行注释
echo 'hello world'
```

- 多行注释

```shell
#!/bin/bash
:<<! 这是多行注释
多行注释
多行注释
!
echo 'hello world'
```

```shell
:<<字符
	注释内容
字符
```

**变量**

- 定义变量

  - 普通变量

    - 方式一：`变量名=变量值`（变量值必须是一个整体，中间没有特殊字符）
    - 方式二：`变量名='变量值'`（单引号中的内容，原样赋值）
    - 方式三：`变量名="变量值"`（如果双引号中有其它变量，会把变量的结果进行拼接，然后赋值）

    > 习惯：数字不加引号，其它默认加双引号

  - 命令变量（将命令的结果赋值给变量）

    - 方式一：==变量名=\`命令\`==(这里是反引号<tab键上方>)
    - 方式二：`变量名=$(命令)`（常用）

- 使用变量

  - 方式一：`$变量名`（非标准写法，图省事）
  - 方式二：`"$变量名"`（非标准写法，图省事）
  - 方式三：`${变量名}`（在双引号里面要使用变量的值）
  - 方式四：`"${变量名}"`（标准使用方式）

- 只读变量：`readonly 变量名`

- 删除变量：`unset 变量名`

#### 数组

| 定义数组         | 数组名=(值1 值2 ... 值n)              | arr=(1 2 3 4 5)                |
| ---------------- | ------------------------------------- | ------------------------------ |
| 给数组的元素赋值 | `数组名[索引]=值`                     | `arr[0]=1`                     |
| 获取元素         | `${数组名[下标]}`                     | `${arr[0]}`                    |
| 获取长度         | `${#数组名[\*]}`<br />`${#数组名[@]}` | `${#arr[*]}`<br />`${#arr[@]}` |

#### 运算符

| 运算符  |    说明     |             举例              |
| :-----: | :---------: | :---------------------------: |
|    +    |    加法     |         expr $a + \$b         |
|    -    |    减法     |         expr \$a - $b         |
|    *    |    乘法     |        expr \$a \\* $b        |
|    /    |    除法     |         expr \$b / $a         |
|    %    |    取余     |         expr \$b % $a         |
|    =    |    赋值     | a=$b （把b变量的值赋给a变量） |
| ++ / -- | 自增 / 自减 |            ((a++))            |

**注意点**

1. 原生的bash不支持简单的数学运算。可以通过其它命令实现：expr
2. 表达式和运算符之间要有空格
3. 完整的表达式要被反引号包含
4. 乘法中不能直接使用*，需要在乘号前加\\转义

举例：==\`expr 2 + 2`==



**字符串运算符**

| 运算符 | 说明                                     | 举例           |
| ------ | ---------------------------------------- | -------------- |
| =      | 检测两个字符串是否相等，相等返回true     | [ \$a = \$b ]  |
| !=     | 检测两个字符串是否不相等，不相等返回true | [ \$a != \$b ] |
| -z     | 检测字符串长度是否为0，为0返回true       | [ -z \$a ]     |
| -n     | 检测字符串长度是否不为0，不为0返回true   | [ -n \$a ]     |
| \$     | 检测字符串是否为空，不为空返回true       | [ \$a ]        |

> `[]`与里面的代码命令有个空格隔开，不能贴在一起
>
> `$?`可以获取上一条语句的执行结果
>
> ==在shell中，0为真，1为假==
>
> `${#字符串}`获取字符串长度



**关系运算符**

| 运算符 |                             说明                             |      举例       |
| :----: | :----------------------------------------------------------: | :-------------: |
|  -eq   |          检测两个数是否相等，相等返回true==equals==          | [ \$a -eq \$b ] |
|  -ne   |      检测两个数是否不相等，不相等返回true==not equals==      | [ \$a -ne \$b ] |
|  -gt   | 检测左边的数是否大于右边的，如果是，则返回true==greater than== | [ \$a -gt \$b ] |
|  -lt   |  检测左边的数是否小于右边的，如果是，返回true==less than==   | [ \$a -lt \$b ] |
|  -ge   | 检测左边的数是否大于等于右边的，如果是，则返回true==greater equals== | [ \$a -ge \$b ] |
|  -le   | 检测左边的数是否小于等于右边的，如果是，则返回true==less equals== | [ \$a -le \$b]  |

==关系运算符只支持数字，不支持字符串，除非字符串的值是数字==



**布尔运算符**

| 运算符 |                     说明                     |             举例              |
| :----: | :------------------------------------------: | :---------------------------: |
|   !    |                   取反运算                   |     [ ! false ] 返回true      |
|   -o   | 或运算，有一个表达式为true 则返回true ==or== | [ \$a -lt 20 -o \$b -gt 100 ] |
|   -a   | 与运算，两个表达式都为true 才返回true==and== | [ \$a -lt 20 -a \$b -gt 100 ] |



**逻辑运算符**

| 运算符 | 说明       | 举例                             |
| ------ | ---------- | -------------------------------- |
| &&     | 逻辑的 AND | [[ true && true ]] 返回true      |
| \|\|   | 逻辑的 OR  | [[ false \|\| false ]] 返回false |



#### 选择语句

**if语法**

```shell
if[ 条件 ]
then
	语句体
fi
```

```shell
if [ 条件 ]
then
	语句体
else
	语句体
fi
```

```shell
if [ 条件1 ]
then
	语句体
elif [ 条件2 ]
	语句体
else
	语句体
fi
```

**小练习**

```shell
#!/bin/bash
# if语句

#if的第一种格式：
#查找一个进程，如果进程存在，就打印true
if [ $(ps -ef | grep -c "ssh") -gt 1 ]
then
	echo "true"
fi
```

**case语法**

```shell
case 值 in
模式1 )
	语句体1
	;;
模式2 )
	语句体2
	;;
esac
```

```shell
v="hhxx"
case "${v}" in
"hhxx")
	echo "好好学习"
	;;
"ttxs")
	echo "天天向上"
	;;
esac
```

#### 循环语句

**for循环**

```shell
for 变量 in 范围
do
	循环体
done
```

```shell
for loop in A B C
do
	echo $loop
done
```

**while循环**

```shell
while 条件
do
	循环体
done
```

```shell
a=1
while [ "${a}" -le 10 ]
do
	echo "${a}"
	((a++))
done
```

#### 函数

**无参无返回值**

```shell
函数名(){
	函数体
}
```

```shell
test(){
	echo "函数测试！"
}
echo "==========="
test
echo "============"
```

**有参无返回值**

```shell
method(){
	echo "第一个参数$1"
	echo "第二个参数$2"
}

method a b
```

**有参有返回值**

```shell
method(){
	echo "接收到参数$1和$2"
	return $(($1 + $2))
}

method 10 20
echo $?
```

**小练习**

> `read 变量名`：表示把键盘录入的数据赋值给这个变量

```shell
#!/bin/bash
#在方法中键盘录入两个整数，并返回这两个整数和

method(){
        echo "请录入第一个数："
        read num1
        echo "请录入第二个数："
        read num2
        echo "两个数分别为：${num1},${num2}"
        return $(($num1 + $num2))
}

method
echo "两数之和为：$?"
```