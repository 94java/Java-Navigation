---
title: "Linux"
order: 2
category:
  - 工具 | 部署

---

# Linux

## 一、基础篇

### 1、初识Linux

**操作系统**：管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石

**主流操作系统**

- 桌面操作系统：Window系列、macOS、Linux
- 服务器操作系统：Linux、Windows Server
- 嵌入式操作系统：Linux
- 移动设备操作系统：Unix（Linux、ios）

**Linux发展历程**

![img](http://images.hellocode.top/b0cdbe588ce94f04b73b803e8ec4381f.png)

- 1984年Minix（只用于教学）
- 1991年编写驱动程序，年底公开Linux内核源码
- 1994年Linux1.0（Linus Torvalds）
- 至此开始流行起来

**Linux特点**

- Linux是一套免费使用和自由传播的类Unix操作系统

- 是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统
- 它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件
- 继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统
- 两个基本思想
  - 一切都是文件
  - 每个软件都有确定的用途
- 完全兼容POSIX1.0标准
- 多用户、多任务
- 良好的界面
- 支持多种平台

**Linux与其它操作系统的区别**

- 开源情况
- 硬件适用
- 本质不同
- 系统界面
- 驱动程序
- 系统使用
- 软件与支持

> Windows更适用于家庭个人使用
>
> Linux更适用于企业服务器使用

**Linux发行商和常见发行版**

- Redhat公司--------Red Hat Linux（最著名的Linux版本、收费）-----免费的CentOS
- CentOS特点：主流、免费、更新方便

### 2、Linux的安装和使用

先安装虚拟机，再安装Centos

#### 2.1. Vmware

**Vmware简介**

- 不需要分区或者重开机就能在同一台PC上使用两种以上的操作系统
- 完全隔离并且保护不同操作系统的环境以及所有的软件、资料
- 不同的操作系统之间还可以进行互动操作
- 有复原功能
- 能够设置并且随时修改操作系统的操作环境
- 常见虚拟机软件：VMware workstation、VirtualBox

**Vmware下载**：https://www.vmware.com/cn.html

**CentOS镜像下载**：https://www.centos.org/download/

*高速下载地址*

- http://mirrors.aliyun.com
- http://mirrors.sohu.com
- http://mirrors.163.com
- http://mirrors.cqu.edu.cn/CentOS

#### 2.2. 目录和文件

- 切换根目录：`cd /`
- 查看目录内容：`ls -l`

**基本介绍**

1. Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录
2. 在Linux世界里，一切皆文件（也会把硬件映射为文件进行管理）

**具体结构**

- *bin*（/usr/bin、/usr/local/bin）：是Binary的缩写，存放最常使用的命令
- sbin（/usr/sbin、/usr/local/sbin）：存放系统管理员使用的系统管理程序
- *home*：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般目录名是以用户名命名
- *root*：系统管理员目录，也称作超级权限者的用户主目录
- lib：系统开机所需要最基本的动态连接共享库，作用类似于Windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库
- lost+found：这个目录下一般是空的，在系统非法关机后，就会存放一些文件
- *etc*：所有的系统管理所需要的配置文件和子目录，比如安装mysql的my.conf
- *usr*：这是一个非常重要的目录，用户的很多应用程序都放在这个目录下，类似于Windows下的program files目录
- *boot*：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件
- proc：是一个虚拟目录，是系统内存的映射，访问这个目录来获取系统信息
- srv：service缩写，存放一些服务启动后需要提取的数据
- sys：这是Linux2.6内核的一个很大的变化，安装了2.6内核中新出现的一个文件系统sysfs
- tmp：存放临时文件的目录
- dev：类似于Windows的设备管理器，把所有的硬件用文件的形式存储
- *media*：Linux系统会自动识别一些设备，例如：U盘，光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下
- *mnt*：系统提供该目录是为了让用户挂在临时文件系统的，我们可以将外部的存储挂载在mnt上，然后进入该目录就可以查看里面的内容了
- opt：这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可以放到该目录下，默认为空
- *usr/local*：这是另一个主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序
- var：存放着不断扩充着的东西，习惯被修改的目录放在这个目录下，包括各种日志文件
- selinux：是一种安全子系统，能控制程序只能访问特定文件，有三种工作模式，可自行设置

#### 2.3. 时间同步

![](http://images.hellocode.top/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5.png)

#### 2.4. 克隆与快照

**克隆**：将原系统完完全全的拷贝一份，原系统丢失后克隆的系统还能正常使用

- 占用空间大
- 原系统不存在，克隆体还能用

**快照**：记录系统当前状态，并不会把系统完整拷贝

- 占用空间小
- 原系统不存在，快照也就无法使用

> 克隆和拍摄快照时都需要关闭虚拟机


## 二、实际操作篇

- 如需远程连接，可以使用XShell、SecureCRT、FinalShell等软件进行连接
- 需要知道对应的Linux服务器ip，在终端使用`ifconfig`可以进行查询
- 查询到Linux服务器IP后，在Windows命令行下使用ping指令可以判断是否连通，如果无法连通，则一定无法进行远程连接，就需要进行检查后连接

### 1、vi和vim编辑器

- Linux会内置vi文本编辑器
- Vim具有程序编辑的能力，可以看作是vi的增强版，可以主动的以文字颜色辨别语法的正确性，方便程序设计。代码补全，编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用

#### 1.1. 三种模式

**正常模式**

- 以vim打开一个档案就直接进入一般模式了（默认的模式）
- 在这个模式中，可以使用【上下左右】按键来移动光标
- 可以使用【删除字符】或【删除整行】来处理档案内容
- 也可以使用【复制、粘贴】来处理文件的数据
- 按`:`进入命令行模式

**插入模式**

- 按下i、I、o、O、a、A、r、R等任何一个字母之后才会进入编辑模式
- 一般来说按i即可
- 输入`Esc`，再输入`：`进入命令行模式

**命令行模式**

- 在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作
- `:wq`：保存退出
- `:q`：不保存退出，`:q!`强制退出，并且不保存

#### 1.2. 快捷键

![](http://images.hellocode.top/1635644-20200320235833308-556504745.png)

**正常模式**

- 拷贝当前行：`yy`，拷贝当前行向下的n行：`nyy`，粘贴：`p`

- 删除当前行`dd`，删除当前行向下的n行：`ndd`
- 到该文档最末行：`G`，最首行：`gg`
- 撤销操作：`u`
- 将光标移动到指定位置：`行号 shift g`

**命令行模式**

- 在文件中查找某个单词：`/关键字`，回车 查找；输入`n`就是查找下一个
- 设置文件行号：`:set nu`，取消文件行号：`:set nonu`

### 2、关机重启和登录注销

#### 2.1. 关机重启

**基本介绍**

- `shutdown -h now`：立刻进行关机
- `shutdown -h 1`：1分钟后关机
- `shutdown -r now`：现在重启计算机
- `halt`：关机，作用和上面一样
- `reboot`：现在重启计算机
- `sync`：把内存的数据同步到磁盘

**注意细节**

- 不论是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中
- 目前的shutdown/reboot/halt等命令均已经在关机前进行了sync

#### 2.2. 登录注销

**基本介绍**

- 登陆时尽量少使用root账号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登陆后使用`su -用户名`命令来切换身份（-可以省略）
- 在提示符下输入logout即可注销用户

**使用细节**

- logout注销指令在图形运行级别无效，在运行级别3下有效

### 3、用户管理

> Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统

**添加用户**

- 基本语法：`useradd 用户名`
- 细节说明
  - 当创建用户成功之后，会自动的创建和用户同名的家目录
  - 也可以通过`useradd -d 指定目录 用户名`，给新创建的用户指定家的目录

**指定/修改密码**

- 基本语法：`passwd 用户名`
- 细节说明
  - 如果不写用户名的话默认修改当前登录的用户密码

**删除用户**

- 基本语法：`userdel 用户名`
- 细节说明
  - `userdel -r 用户名`：删除用户及其家目录
  - 不加`-r`只删除用户，保留家目录
  - 一般情况下，建议保留家目录

**查询用户**

- 基本语法：`id 用户名`
- 细节说明
  - 当用户不存在时，返回无此用户

**切换用户**

- 在操作Linux时，如果当前用户的权限不够，可以通过`su -`指令，切换到高权限用户，比如root
- 基本用法：`su - 用户名`
- 细节说明
  - 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要
  - 当需要返回到原用户时，使用`exit/logout`指令

**查看当前用户信息**

- 基本语法：`whoami/who am i`
- 细节
  - 如果通过切换用户指令切换后，使用该指令查询的是第一次登录时的用户

**用户组**

- 类似于角色，系统可以对有共性的多个用户进行统一的管理
- 新增组：`groupadd 组名`
- 删除组：`groupdel 组名`
- 增加用户时直接加上组：`useradd -g 用户组 用户名`
- 修改用户组：`usermod -g 新用户组 用户名`
  `usermod -d 目录名 用户名`改变该用户登录的初始目录（用户需要有进入目录的权限）

- 细节
  - 如果在新增用户时，没有指定分组，会默认新建一个与用户同名的组并将该用户加入对应的组

*用户和组相关文件*

- /etc/passwd
  - 用户（user）的配置文件，记录用户的各种信息
  - 每行的含义：`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell`
- /etc/shadow
  - 口令的配置文件
  - 每行的含义：`登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`
- /etc/group
  - 组（group）的配置文件，记录Linux包含的组的信息
  - 每行的含义：`组名:口令:组标识号:组内用户列表`

### 4、实用指令

#### 4.1. 运行级别

**基本介绍**

运行级别说明

0. 关机
1. 单用户【找回丢失密码】
2. 多用户状态没有网络服务
3. 多用户状态有网络服务
4. 系统未使用保留给用户
5. 图形界面
6. 系统重启

*常用运行级别是3和5，也可以指定默认运行级别*

- 通过`init [0~6]`可以切换上面的运行级别

> 如果输入`init 3`将进入命令行界面，`init 0`关机，`init 6`重启......
>
> 在centos7以前，在`/etc/inittab`文件中进行修改

*默认运行级别*

- 查询当前默认运行级别：`systemctl get-default`
- 修改默认运行级别为3级别：`systemctl set-default multi-user.target`
- 在修改后，重启将进入所设置的默认运行级别

**找回root密码**（centos 7.6）

1. 启动系统，在开机界面按`e`进入编辑界面
2. 进入编辑界面，使用键盘上的上下键把光标往下移动，找到以“Linux 16”开头内容所在的行数，在行的最后输入：`init=/bin/sh`（进入单用户运行级别）
3. 完成输入后，直接按快捷键`ctrl + x`进入单用户模式
4. 接着，在光标闪烁位置输入：`mount -o remount,rw /`（注意，各个单词间有空格），完成后按键盘的回车键（Enter）
5. 再在新的一行最后输入：`passwd`，完成后按键盘的回车键。输入密码，然后再次确认密码即可，密码修改成功后，会显示passwd.....的样式，说明密码修改成功
6. 接着，在鼠标闪烁的位置中（最后一行），输入`touch /.autorelabel`，完成后按回车键
7. 继续在光标闪烁的位置处，输入`exec /sbin/init`，按回车，等待系统自动修改密码（过程时间可能有点长，耐心等待）。完成后，系统自动重启，新的密码就生效了

#### 4.2. 帮助指令

- man：`man [命令或配置文件] `（功能描述：获得帮助信息）
- help：`help 命令`（获得shell内置命令的帮助信息）
- 百度搜索更直接

> 在查看帮助信息时，一页展示不下的话，按空格键会继续向下走

#### 4.3. 文件目录指令

**目录操作**

- *pwd指令*：`pwd`（显示当前工作目录的绝对路径）
- *ls指令*：`ls [选项] [目录或是文件]`
  - `-a`：显示当前目录所有的文件和目录，包括隐藏的
  - `-l`：以列表的方式显示信息（`ll`指令作用相同）
  - `-lh`：便于查看，文件大小将展示为k
- *cd指令*：`cd [参数]`（切换到指定目录）
  - `cd ~`或者`cd`：回到自己的家目录，比如你是root，`cd ~`就会回到/root
  - `cd ..`：回到当前目录的上一级目录

**文件操作**

- *mkdir指令*：`mkdir [选项] 要创建的目录`（用于创建目录）
  - `-p`：创建多级目录
- *rmdir指令*：`rmdir [选项] 要删除的空目录`（用于删除目录）
  - rmdir删除的是空目录，如果目录下有内容时无法进行删除
  - 要删除非空目录，需要使用`rm -rf 要删除的目录`

- *touch指令*：`touch 文件名称`（创建空文件）

**功能指令**

- *cp指令*：`cp [选项] 源文件 目的地`（拷贝文件到指定目录）
  - `-r`：递归复制整个文件夹
  - 强制覆盖不提示的方法：`\cp`
- *rm指令*：`rm [选项] 要删除的文件或目录`（移除文件或目录）
  - `-r`：递归删除整个文件夹
  - `-f`：强制删除不提示
- *mv指令*（移动文件与目录或重命名）
  - `mv 旧文件名 新文件名`（重命名）
  - `mv 源文件 目的地`（移动文件）

**查看指令**

- *cat指令*：`cat [选项] 要查看的文件`（查看文件内容）
  - `-n`：显示行号
  - cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 `管道命令 | more`
  - 例如：`cat -n /etc/profile | more`
- *more指令*：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键
  
  - 基本语法：`more 要查看的文件`
  - 空格：向下翻一页
  - 回车：向下翻一行
  - q：立即离开more，不再显示该文件内容
  - Ctrl + F：向下滚动一屏
  - Ctrl + B：返回上一屏
  - =：输出当前的行号
  - `:f`：输出文件名和当前行的行号
- *less指令*：less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率
  
  - 基本语法：`less 要查看的文件`
  - 空格：向下翻一页
  - pagedown：向下翻一页
  - pageup：向上翻一页
  - /字串：向下搜寻【字串】。n向下查找，N向上查找
  - ?字串：向上搜寻【字串】。n向上查找，N向下查找
- q：离开less这个程序
  
- *echo指令*：`echo [选项] [输出内容]`（输出内容到控制台）
- *head指令*：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容
  - `head 文件`：查看文件头10行内容
  - `head -n 5 文件`：查看文件头5行内容，5可以是任意行数
- *tail指令*：用于输出文件中尾部的内容，默认情况下tail指令显示文件末尾10行内容
  - `tail 文件`：查看文件尾10行内容
  - `tail -n 5 文件`：查看文件尾5行内容，5可以是任意行数
  - `tail -f 文件`：实时追踪该文档的所有更新
- *> 指令和 >> 指令*
  - `>`：输出重定向（覆盖原内容）
  - `>>`：追加（不覆盖原内容）
  - 基本语法
    - `ls -l > 文件`：列表的内容写入a.txt中，覆盖写
    - `ls -al >> 文件`：列表的内容追加到aa.txt的末尾
    - `cat 文件1 > 文件2`：将文件1的内容覆盖到文件2
    - `echo "内容" >> 文件`
    - `cal >> /home/date.txt`：将日历信息追加到data.txt中（文件不存在自动创建）
  
  > 在追加内容时，如果目标文件不存在，将会自动创建出来
  >
  > `cal`：显示当前日历信息

**其他指令**

- *ln指令*：软链接也称为符号链接，类似于Windows里的快捷方式，主要存放了链接其他文件的路径（link）
  - 基本语法：`ln -s [原文件或目录] [软链接名]`（给原文件创建一个软链接）
  - 当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录
  - 删除软链接：和删除文件一样（`rm 软链接名`）
  - 创建软链接时最好使用绝对路径，否则会出现*符号连接的层数过多*等问题
- *history指令*：查看已经执行过的历史命令，也可以执行历史命令
  - 基本语法：`history`（查看执行过的历史命令）
  - `history n`：查看最近执行的n条指令
  - `!5`：执行曾经执行过的第5条指令

#### 4.4. 时间日期指令

- date指令：显示当前日期

**显示日期**

1. `date`：显示当前时间
2. `date +%Y`：显示当前年份
3. `date +%m`：显示当前月份
4. `date +%d`：显示当前是哪一天
5. `date "+%Y-%m-%d %H:%M:%S"`：显示年月日时分秒

**设置日期**

- `date -s 字符串时间`：设置系统当前时间

**cal指令**

- 查看日历指令
- 基本语法：`cal [选项]`（不加选项，显示本月日历）
- `cal 2022`：显示2022年全年日历

#### 4.5. 查找指令

**find指令**

- 将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端

- 基本语法：`find [搜索范围] [选项]`
- `-name<查询方式>`：按照指定的文件名查找模式查找文件
- `-user<用户名>`：查找属于指定用户名所有文件
- `-size<文件大小>`：按照指定的文件大小查找文件（单位：k，M，G）
- 在home下查找hello.txt文件：`find /home -name hello.txt`
- 查找整个Linux下大于200M的文件（+n大于，-n小于，n等于）：`find / -size +200M`

**locate指令**

- locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新Locate时刻

- 基本语法：`locate 搜索文件`
- 由于locate指令基于数据库进行查询，所以在第一次运行前，必须使用`updatedb`指令创建locate数据库

**which指令**

- 可以查看某个指令在哪个目录下，比如查看ls指令：`which ls`

**grep指令和管道指令|**

- grep过滤查找，管道符`|`，表示将前一个命令的处理结果输出传递给后面的命令处理
- 基本语法：`grep [选项] 查找内容 源文件`
  - `-n`：显示匹配行及行号
  - `-i`：忽略字母大小写 

#### 4.6. 压缩和解压

**gzip/gunzip指令**

- gzip用于压缩文件，gunzip用于解压缩
- 基本语法
  - `gzip 文件`：压缩文件，只能将文件压缩为*.gz文件
  - `gunzip 文件.gz`：解压缩文件命令

**zip/unzip指令**

- zip用于压缩文件，unzip用于解压文件，这个在项目打包发布中很常用
- 基本语法
  - `zip [选项] xxx.zip 将要压缩的内容`：压缩文件和目录的命令
    - `-r`：递归压缩，即压缩目录
  - `unzip [选项] xxx.zip`：解压缩文件
    - `-d 目录`：指定解压后文件的存放目录

**tar指令**

- tar指令是打包指令，最后打包成的文件是.tar.gz的文件
- `tar [选项] xxx.tar.gz 打包的内容`：打包目录，压缩后的文件格式.tar.gz
  - `-c`：产生.tar打包文件
  - `-v`：显示详细信息
  - `-f`：指定压缩后的文件名
  - `-z`：打包同时压缩
  - `-x`：解包.tar文件
- 案例
  - 压缩多个文件：`tar -zcvf ab.tar.gz a.txt b.txt`
  - 压缩目录：`tar -zcvf home.tar.gz /home`
  - 解压到当前目录：`tar -zxvf ab.tar.gz`
  - 解压到指定目录：`tar -zxvf ab.tar.gz -C /root`

> 使用gzip压缩会删除源文件，使用其他两个指令进行压缩不会删除源文件

#### 4.7. 组管理

> 在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者、所在组、其他组的概念

**文件/目录 所有者**

- 一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者
- 查看文件的所有者：`ls -ahl`（a全部，l详细信息，h将大小展示为以k为单位的数值）
- 修改文件的所有者：`chown 用户名 文件名`
- 修改所有者和所在组：`chown newowner:newgroup 文件/目录`
- `-R`：如果是目录，则使其下所有子文件或目录递归生效

**文件/目录 所在组**

- 当某个用户创建了一个文件后，这个文件的所在组就是该用户的所在组
- 查看文件/目录所在组：`ls -ahl`
- 修改文件所在的组：`chgrp 组名 文件名`
- `-R`：如果是目录，则使其下所有子文件或目录递归生效

**其他组**

- 除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组

#### 4.8. 权限管理

- ls -alh显示内容如下：

`-rw-r--r--.  1 hellocode hellocode    0 11月 23 20:21 apple.txt`

> 在hellocode前的1含义
>
> 文件：硬连接数（ln）
>
> 目录：子目录数
>
> 11月前的0代表文件的大小（字节）
>
> 最后的日期代表最后修改的时间
>
> 第一个hellocode代表所属用户，第二个hellocode代表所属组

**0-9位说明**

1. 第0位确定文件类型（d, -, l, c, b）

   -是普通文件，相当于Windows的文件

   l是链接，相当于Windows的快捷方式
   d是目录，相当于Windows的文件夹
   c是*字符设备*文件，鼠标，键盘
   b是块设备，比如硬盘

2. 第1-3位确定所有者（该文件的所有者）拥有该文件的权限  ---User

3. 第4-6位确定所属组（同用户组的）拥有该文件的权限，---Group

4. 第7-9位确定其他用户拥有该文件的权限 ---Other

**权限详解**

rwx作用到文件

1. `r`代表可读（read）：可以读取，查看
2. `w`代表可写（write）：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在目录有写权限，才能删除该文件
3. `x`代表可执行（execute）：可以被执行

rwx作用到目录

1. `r`代表可读（read）：可以读取，ls查看目录内容
2. `w`代表可写（write）：可以修改，对目录内创建+删除+重命名目录
3. `x`代表可执行（execute）：可以进入该目录，例如cd

**修改权限**

- 通过chmod指令，可以修改文件或者目录的权限

*第一种方式：+、-、=变更权限*
u：所有者；g：所有组；o：其他人；a：所有人（u、g、o的总和）

1. 为文件/目录设置对应的权限：`chmod u=rwx,g=rx,o=x 文件/目录名`
2. 为文件/目录添加对应的权限：`chmod o+w 文件/目录名`
3. 为文件/目录移除对应的权限：`chmod a-x 文件/目录名`

*第二种方式，通过数字变更权限*

r=4 w=2 x=1       rwx=4+2+1=7

`chmod u=rwx,g=rx,o=x 文件目录名`

相当于`chmod 751`

### 5、定时任务调度

- 任务调度：是指系统在某个时间执行的特定的命令或程序
- 任务调度分类
  1. 系统工作：有些重要的工作必须周而复始的执行，比如病毒扫描等
  2. 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份

#### 5.1. crond定时任务

- crontab 进行 定时任务的设置

- 基本语法：`crontab [选项]`

- 重启任务调度：`service crond restart`

- 常用选项

  - `-e`：编辑crontab定时任务
  - `-l`：查询crontab任务
  - `-r`：删除当前用户所有的crontab任务（终止任务调度）

- 快速入门

  - 设置任务调度文件：`/etc/crontab`
  - 设置个人任务调度，执行`crontab -e`命令
  - 接着输入任务到调度文件
    如`*/1 * * * * ls -l /etc/ > /tmp/to.txt`命令
    意思说每小时的每分钟执行`ls -l /etc/ > /tmp/to.txt`命令

- 参数细节说明

  | 项目     | 含义                 | 范围                    |
  | -------- | -------------------- | ----------------------- |
  | 第一个 * | 一小时当中的第几分钟 | 0-59                    |
  | 第二个 * | 一天当中的第几小时   | 0-23                    |
  | 第三个 * | 一个月当中的第几天   | 1-31                    |
  | 第四个 * | 一年当中的第几月     | 1-12                    |
  | 第五个 * | 一周当中的星期几     | 0-7（0和7都代表星期日） |

  | 特殊符号 | 含义                                                         |
  | -------- | ------------------------------------------------------------ |
  | `*`      | 代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思 |
  | `,`      | 代表不连续的时间。比如0 8,12,16 * * *命令，就代表在每天8点0分，12.0分，16.0分都执行一次 |
  | `-`      | 代表连续的时间范围。比如0 5 * * 1-6命令，代表在周一到周六的凌晨5.0分执行命令 |
  | `*/n`    | 代表每隔多久执行一次。比如*/10 * * * *命令，代表每隔10分钟就执行一次 |

- 案例

  | 时间                | 含义                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | `45 22 * * * 命令`  | 在每天22:45执行命令                                          |
  | `0 17 * * 1 命令`   | 在每周一17:00执行命令                                        |
  | `0 5 1,15 * * 命令` | 在每月1日和15日的5:00执行命令                                |
  | `40 4 * * 1-5命令`  | 在每周一到周五的4:40执行命令                                 |
  | `*/10 4 * * * 命令` | 每天凌晨4时，隔10分钟执行一次                                |
  | `0 0 1,15 * 1 命令` | 每月1号和15号，每周一00:00执行命令（星期和几号最好不要同时出现，因为定义的都是天，容易让管理员混乱） |

- 应用实例

  1. 每个1分钟，就将当前的日期信息，追加到/tmp/mydate 文件中
     `*/1 * * * * date >> /tmp/mydate`

  2. 每个1分钟，将当前日期和日历都追加到/home/mycal 文件中

     - 编写脚本：my.sh（设置可执行权限）

       ```shell
       date >> /home/mycal
       cal >> /home/mycal
       ```

     - 设置定时任务：`*/1 * * * * /home/my.sh`

  3. 每天凌晨2:00 将mysql数据库 testdb，备份到文件中。
     `0 2 * * * mysqldump -u root -p 123456 testdb >> /home/db.bak`

#### 5.2. at定时任务

- at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。

- 默认情况下，atd守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业

- at命令是一次性定时计划任务执行完一个任务后不再执行此任务了

- 在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看
  `ps -ef | grep atd`

- 命令格式

  - `at [选项] [时间]`
  - ctrl + D 结束at命令的输入

- 命令选项

  | 选项          | 含义                                                         |
  | ------------- | ------------------------------------------------------------ |
  | -m            | 当指定的任务被执行完成后，将给用户发送邮件，即使没有标准输出 |
  | -I            | atq的别名                                                    |
  | -d            | atrm的别名                                                   |
  | -v            | 显示任务将被执行的时间                                       |
  | -c            | 打印任务的内容到标准输出                                     |
  | -V            | 显示版本信息                                                 |
  | -q <队列>     | 使用指定的队列                                               |
  | -f <文件>     | 从指定文件读入任务而不是从标准输入读入                       |
  | -t <时间参数> | 以时间参数的形式提交要运行的任务                             |

- 时间定义

  1. 接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。例如：04:00
  2. 使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间
  3. 采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。例如：12pm
  4. 指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。例如:04:00 2021-03-1 
  5. 使用相对计时法。指定格式为:now + count time-units ,now就是当前时间，time-units是时间单位，这里能够是 minutes（分钟)、hours (小时)、days (天)、weeks（星期)。count是时间的数量，几天，几小时。例如: now + 5 minutes 
  6. 直接使用 today (今天)、tomorrow (明天）来指定完成命令的时间。

- 应用实例

  1. 2天后的下午5点执行 `/bin/ls /home`
     `at 5pm + 2days`
     `/bin/ls /home`
     Ctrl + D（2次）

  2. atq命令来查看系统中没有执行的工作任务

  3. 明天17点钟，输出时间到指定的文件内，比如：/root/date100.log
     `at 5pm tomorrow`
     `date > /root/date100.log`
     Ctrl + D（2次）

  4. 2分钟后，输出时间到指定文件内，比如 /root/date200.log
     `at now + 2 minutes`
     `date > /root/date200.log`

     Ctrl + D（2次）

  5. 删除已经设置的任务，`atrm 编号`

### 6、磁盘分区、挂载

- Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分
- Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得

![在这里插入图片描述](http://images.hellocode.top/916eb47e51244fb893949f25134ba92c.png)

#### 6.1. Linux分区

**硬盘说明**

![image-20221126203704953](http://images.hellocode.top/image-20221126203704953.png)

1. Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘
2. 对于*IDE硬盘*，驱动器标识符为`hdx~`，其中`hd`表明分区所在设备的类型，这里是指IDE硬盘了。`x`为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,` ~`代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例如，hda3 表示为第一个IDE硬盘上的第三个主分区或扩展分区，hdb2 表示为第二个IDE硬盘上的第二个主分区或扩展分区
3. 对于*SCSI硬盘*则标识为 `sdx~`，SCSI硬盘是用 `sd`来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样

**磁盘情况查询**

- 基本语法：`df -h`

*查询指定目录的磁盘占用情况*

![image-20221126212153964](http://images.hellocode.top/image-20221126212153964.png)

- 基本语法：`du -h /目录`（查询指定目录的磁盘占用情况，默认为当前目录）
- `-s`：指定目录占用大小汇总
- `-h`：带计量单位
- `-a`：含文件
- `--max-depth=1`：子目录深度
- `-c`：列出明细的同时，增加汇总量

> 查询 /opt 目录的磁盘占用情况，深度为1：`du -h --max-depth=1 /opt`

**工作实用指令**

1. 统计 /opt 文件夹下文件的个数：`ls -l /opt | grep "^-" | wc -l`
2. 统计 /opt 文件夹下目录的个数：`ls -l /opt | grep "^d" | wc -l`
3. 统计 /opt 文件夹下文件的个数，包括子文件夹里的：`ls -lR /opt | grep "^-" | wc -l`
4. 统计 /opt 文件夹下目录的个数，包括子文件夹里的：`ls -lR /opt | grep "^d" | wc -l`
5. 以树状显示目录结构：`tree /opt`
   - 如果没有tree指令，需要先安装
   - `yum install tree`

#### 6.2. 挂载

**查看所有设备挂载情况**

- 命令：`lsblk`或`lsblk -f`

![image-20221126204651331](http://images.hellocode.top/image-20221126204651331.png)

**经典案例**

> 这里以增加一块硬盘为例来熟悉磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念

*如何增加一块硬盘*

1. 虚拟机添加硬盘
   设置——添加——硬盘（添加后需要重启系统才能识别）
   重启后可以通过`lsblk`指令来查看

2. 分区

   - 分区命令：`fdisk /dev/sdb`
   - `m`：显示命令列表
   - `p`：显示磁盘分区，同`fdisk -l`
   - `n`：新增分区
   - `d`：删除分区
   - `w`：写入并退出

   > 开始分区后输入n，新增分区，然后选择p，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。

   ![image-20221126210248362](http://images.hellocode.top/image-20221126210248362.png)

3. 格式化（给分区指定文件系统）

   - 格式化磁盘分区命令：`mkfs -t ext4 /dev/sdb1`（ext4是分区类型）

4. 挂载（将一个分区与一个目录联系起来）

   - 挂载：`mount 设备名称 挂载目录`
     - `mount /dev/sdb1 /newdisk`
   - 卸载：`umount 设备名称 或者 挂载目录`
     - `umount /dev/sdb1`或者`umount /newdisk`

   > 注意：用命令行挂载重启后会失效

5. 设置可以自动挂载（永久挂载）

   - 通过修改`/etc/fstab`实现挂载（除了UUID指定，也可以按照下图方式指定）
   - 添加完成后，执行`mount -a`即刻生效

   ![image-20221126211407576](http://images.hellocode.top/image-20221126211407576.png)

### 7、网络配置

![img](http://images.hellocode.top/2441202-20220301072722870-1945298592.png)

- windows查看网络配置：`ipconfig`
- Linux查看网络配置：`ifconfig`
- ping测试主机之间网络连通性：`ping 目的主机`（测试当前服务器是否可以连接目的主机）

**Linux网络环境配置**

*自动获取*

- 登陆后，通过界面来设置自动获取ip

- 特点：Linux启动后会自动获取ip，缺点是每次自动获取的ip可能不一样

*指定ip*

- 直接修改配置文件来指定ip，并可以连接到外网（程序员推荐）
- 编辑 `vi /etc/sysconfig/network-scripts/ifcfg-ens33`
- 要求：将ip地址配置成静态的，例如：192.168.36.128

- ifcfg-ens33 文件说明

```shell
DEVICE=eth0　　　　　　　　　　#接口名(设备，网卡)
HWADDR =00:0C:2x:6x:0x:xx 　　 #MAC 地址
TYPE=Ethernet　　　　　　　　　 #网络类型(通常是Ethemet)
UUID=926a57ba-92c6-4231 -bacb-f27e5e6a9f44 　　#随机 id
#系统启动的时候网络接口是否有效 (yes/no)
ONBOOT　　yes
```

*配置静态ip方法*

```shell
# IP的配置方法 [none|static|bootp|dhcp] (引导时不使用协议|静态分配IP|BOOTP 协议|DHCP协议)
# 添加下方内容
BOOTPROTO=static
#IP地址
IPADDR=192.168.36.128
#网关
GATEWAY=192.168.36.2
#域名解析器
DNS1=192.168.36.2
```

> 配置完还需要修改vm的虚拟网络配置

- 重启网络服务或者重启系统生效：`service network restart`或者`reboot`

**设置主机名和hosts映射**

*设置主机名*

1. 为了方便记忆，可以给Linux系统设置主机名，也可以根据需要修改主机名
2. 指令：`hostname`（查看主机名）
3. 修改文件在 /etc/hostname 指定
4. 修改后，重启生效

*设置host映射*

如何通过主机名找到（例如ping）某个Linux系统

- Windows
  在 C:\Windows\System32\drivers\etc\hosts 文件指定即可
  例如：192.168.36.128 HelloCode
- Linux
  在 /etc/hosts 文件指定
  例如：192.168.36.1 LAPTOP-R0ND1VG7

**主机名解析过程分析**

- Hosts
  一个文本文件，用来记录IP和hostname（主机名）的映射关系
- DNS
  1. DNS，就是Domain Name System的缩写，翻译过来就是域名系统
  2. 是互联网上作为域名和IP地址相互映射的一个分布式数据库

*实例：用户在浏览器输入了www.baidu.com*

1. 浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用   这个IP完成解析;如果没有,则检查DNS解析器缓存，如果有直接返回iP完成解析。 这两个缓存，可以理解为本地解析器缓存 
2. 一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址(DNS解析记录).
   `ipconfig /displaydns` //DNS域名解析缓存 
   `ipconfig /flushdns` //手动清理dns缓存
   ![在这里插入图片描述](http://images.hellocode.top/e623e9e1f4524b738f037e1ee4de6ce6.png)
3. 如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中  有没有配置对应的域名IP映射，如果有，则完成解析并返回。
4. 如果 本地DNS解析器缓存 和 hosts文件中均没有找到对应的IP则到域名服务DNS进行解析域

![在这里插入图片描述](http://images.hellocode.top/f115896eb23c45efa973ed6bcd86c0fe.png)

### 8、进程管理

- 在Linux中，每个*执行的程序*都称为一个进程。每一个进程都分配一个id号（pid：进程号）
- 每个进程都可能以两种方式存在的。*前台*与*后台*，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行
- 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才结束

#### 8.1. 显示系统执行的进程

- ps命令是用来查看目前系统中，有哪些正在执行，以及它们的执行状况。可以不加任何参数

**命令**

- `ps -a`：显示当前终端的所有进程信息
- `ps -u`：以用户的格式显示进程信息
- `ps -x`：正在执行的命令或进程名

**说明**

- *PID*：进程识别号
- *TTY*：终端机号
- *TIME*：此进程所消CPU时间
- *CMD*：正在执行的命令或进程名
- *%CPU*：占用CPU的百分比
- *%MEM*：占用物理内存的百分比
- *STAT*：运行状态（s表示休眠，r运行状态，Z僵死进程）

#### 8.2. 父子进程

> 要求：以全格式显示当前所有的进程，查看进程的*父进程*

- `ps -ef`：以全格式显示当前所有的进程
  - `-e`：显示所有进程
  - `-f`：全格式
- 参数说明
  - C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高
  - STIME：进程启动的时间
  - TTY：完整的终端名称
  - CMD：启动进程所用的命令和参数

#### 8.3. 终止进程

- 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用`kill`命令来完成此项任务
- 基本语法
  - `kill [选项] 进程号`：通过进程号杀死/终止进程
  - `killall 进程名称`：通过进程名称杀死进程（也会终止子进程），也支持通配符，这在系统因负载过大而变得很慢时很有用
- 常用选项
  - `-9`：表示强迫进程立刻停止
  - `-u 用户名`：杀死这个用户中的所有进程
- 案例
  - 踢掉某个非法登录的用户
    `ps -aux | grep sshd`查询对应用户登录时的进程号
    `kill 对应的进程号`踢掉对应的非法用户
  - 终止远程登陆服务sshd，在适当时候再次重启sshd服务(远程sshd，本地终端bash)
    `kill sshd对应的进程号`
    `/bin/systemctl start sshd.service`：重启sshd

#### 8.4. 查看进程树

- 基本语法：`pstree [选项]`（可以更加直观的来看进程信息）
- 常用选项
  - `-p`：显示进程的pid
  - `-u`：显示进程的所属用户

#### 8.5. 服务管理

> 服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysqld，sshd 防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点

**service管理指令**

- `service 服务名 [start | stop | restart | reload | status]`
- 在CentOS7.0后 很多服务不再使用 service，而是 systemctl
- service 指令管理的服务在 /etc/init.d 查看
- 查看服务名
  - 方式一：使用setup -> 系统服务，就可以看到全部（`setup`）
  - 方式二：/etc/init.d 能看到service 指令管理的服务（`ls -l /etc/init.d`）

**服务的运行级别**

*Linux系统有7种运行级别（runlevel）*：常用的是级别3和级别5

- 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
- 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
- 运行级别2：多用户状态（没有NFS），不支持网络
- 运行级别3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式
- 运行级别4：系统未使用，保留
- 运行级别5：X11控制台，登陆后进入图形GUI模式
- 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动

**chkconfig指令**

*介绍*

- 通过chkconfig 命令可以给服务的各个运行级别设置 自启动/关闭
- chkconfig 指令管理的服务在/etc/init.d 查看
- 注意：CentOS7.0 后，很多服务使用 systemctl 管理

*基本语法*

- 查看服务：`chkconfig --list [| grep xxx]`
- `chkconfig 服务名 --list`
- `chkconfig --level 5 服务名 on/off`

> chkconfig 重新设置服务后自启动或关闭，需要重启机器reboot生效

**systemctl管理指令**

- 基本语法：`systemctl [start | stop | restart | status] 服务名`
- systemctl指令管理的服务在 /usr/lib/systemd/system 查看

*设置服务的自启动状态*

- `systemctl list-unit-files [| grep 服务名]`：查看服务开机启动状态，grep可以进行过滤
- `systemctl enable 服务名`：设置服务开机启动
- `systemctl disable 服务名`：关闭服务开机启动
- `systemctl is-enabled 服务名`：查询某个服务是否是自启动的

*细节讨论*

- 关闭或者启用防火墙后，立即生效。（`telnet 测试 某个端口即可`）
- 这种方式只是临时生效，当重启系统后，还是回归到以前对服务的设置
- 如果希望设置某个服务自启动或关闭永久生效，要使用 `systemctl [enable | disable] 服务名 

**防火墙**

> 在真正的生产环境中，往往需要将防火墙打开，但是问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这是，需要打开指定的端口。比如80、22、8080等。

- 打开端口：`firewall-cmd --permanent --add-port=端口号/协议`
- 关闭端口：`firewall-cmd --permanent --remove-port=端口号/协议`
- 重新载入，才能生效：`firewall-cmd --reload`
- 查询端口是否开放：`firewall-cmd --query-port=端口/协议`

> 查看对应端口的协议号：`netstat -anp | more`

#### 8.6. 动态监控

> `top`与`ps`命令很相似。他们都用来显示正在执行的进程。Top 与 ps最大的不同之处，在于 top在执行一段时间可以更新正在运行的进程

`top [选项]`

- `-d 秒数`：指定top命令每隔几秒更新。默认3秒
- `-i`：使top不显示任何闲置或者僵死进程
- `-p`：通过指定监控进程id来仅仅监控某个进程的状态

**交互操作说明**

> 在top命令输入后，进入监控面板，输入下方指令进行交互（大小写敏感 ）

| 操作 | 功能                    |
| ---- | ----------------------- |
| P    | 以CPU使用率排序【默认】 |
| M    | 以内存的使用率排序      |
| N    | 以PID排序               |
| q    | 退出top                 |
| u    | 监控指定用户            |
| k    | 终止指定用户            |

#### 8.7. 监控网络状态

`netstat [选项]`

- `-an`：按一定顺序排列输出
- `-p`：显示哪个进程在调用

### 9、RPM和YUM

#### 9.1. RPM

> rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式虽然搭上了RedHat的标志，但理念是通用的

Linux的分发版本都有采用（suse，redhat，centos等），可以算是公认的行业标准了

**rpm包名基本格式**

一个rpm包名：firefox-60.2.2-1.el7.centos.x86_64

- 名称：firefox

- 版本号：60.2.2-1

- 适用操作系统：el7.centos.x86_64（表示centos7.x的64位系统，如果是i686、i386表示32位系统，noarch表示通用）

**rpm包的查询指令**

- 查询所有安装的rpm包：`rpm -qa`

  查询已安装的rpm列表：`rpm -qa | grep xx`

- 查询软件包是否安装：`rpm -q 软件包名`

- 查询软件包信息：`rpm -qi 软件包名`

- 查询软件包中的文件：`rpm -ql 软件包名`

- 查询文件所属的软件包：`rpm -qf 文件全路径名`

**卸载rpm包**

- `rpm -e RPM包的名称`（erase：擦除）
- 如果其他软件包依赖于你要卸载的软件包，卸载时会产生错误信息

> 如果要删除foo这个rpm包，可以增加参数`--nodeps`，就可以强制删除，但是一般不推荐，可能会导致依赖于该软件包的程序无法运行

**安装rpm包**

`rpm -ivh RPM包全路径名称`

- `i`（install）：安装
- `v`（verbose）：提示
- `h`（hash）：进度条

#### 9.2. Yum

> Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包

**基本指令**

- 查询yum服务器是否有需要安装的软件：`yum list | grep xx软件列表`
- 安装指定的yum包：`yum install xxx`

## 三、高级篇

### 1、Shell编程

> Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序

- Linux运维工程师在进行服务器集群管理时，需要编写Shell程序来进行服务器管理
- 对于JavaEE和python程序员来说，工作的需要，可能需要编写一些Shell脚本来进行程序或者服务器的维护，比如定时备份数据库

#### 1.1. 执行方式

**脚本格式要求**

1. 脚本以`#!/bin/bash`开头
2. 脚本需要有可执行权限

**常用的执行方式**

1. 输入脚本的绝对路径或者相对路径
2. sh+脚本（没有执行权限也能执行）

**注释**

- 单行：`#内容`
- 多行：`:<<! 内容 !`

#### 1.2. 变量

> Linux Shell中的变量分为，系统变量和用户自定义变量

- 系统变量：`$HOME`、`$PWD`、`$SHELL`、`$USER`等等

- 显示当前shell中的所有变量：`set`

##### 1.2.1 变量的基本使用

- 定义变量：`变量名=值`（等号两侧不能有空格）

- 输出变量：`$变量名`

- 撤销变量：`unset 变量值`

- 声明静态变量：`readonly 变量名`（不能unset）

- 将命令的返回值赋给一个变量

  ```shell
  #方式一：
  A=`date`
  #方式二：
  A=$(date)
  ```


> 使用变量时，用单引号的时候`$`会原样输出，不用引号或者使用双引号会将`$变量名`替换为对应的变量

**变量规则**

1. 变量名称可以由字母、数字、下划线组成，但是不能以数字开头。
2. 等号两侧不能有空格
3. 变量名称一般习惯为大写，这是一个规范

##### 1.2.2 设置环境变量

> 环境变量操作的文件为：`/etc/profile`

- 将Shell变量输出为环境变量/全局变量：`export 变量名=变量值`
- 让修改后的配置信息立即生效：`source 配置文件`
- 查询环境变量的值：`echo $变量名`

##### 1.2.3 位置参数变量

当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置变量

比如：`./myshell.sh 100 200`，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息

*基本语法*

- `$n`：n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如`${10}`
- `$*`：这个变量代表命令行中所有的参数，`$*`把所有的参数看成是一个整体
- `$@`：这个变量也代表命令行中所有的参数，不过`$@`把每个参数区分对待
- `$#`：这个变量代表命令行中所有参数的个数

##### 1.2.4 预定义变量

> 就是Shell设计者事先已经定义好的变量，可以直接在shell脚本中使用（这部分了解即可）

- `$$`：当前进程的进程号（pid）
- `$!`：后台运行的最后一个进程的进程号（pid）
- `$?`：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己决定），则证明上一个命令执行不正确了

> 以后台方式执行一个指令`./test.sh &`，就是命令末尾加上`&`

#### 1.3. 运算符

- `$((运算式))`或`$[运算式]`或者`expr m + n`（expression）
- 注意expr运算符间要有空格（不加空格就是拼接），希望将结果赋给某个变量需要用到反引号
- `expr m - n`
- `expr \*,/,%`：乘、除、取余（乘法前面有一个`\`）
- 推荐使用`$[运算式]`

#### 1.4. 条件判断

`[ condition ]`

> 注意：condition前后要有空格

- 非空返回true
- 可以使用`$?`验证（0为true，>1为false）

**范例**

- `[ HelloCode ]`：返回true
- `[]`：返回false
- `[ condition ] && echo OK || echo notok`：条件满足，执行后面的语句

**常用判断条件**

- 字符串比较：`=`
- 两个整数比较
  - `-lt`小于；`-le`小于等于
  - `-eq`等于
  - `-gt`大于；`-ge`大于等于
  - `-ne`不等于
- 按照文件权限进行判断
  - `-r`：有读的权限
  - `-w`：有写的权限
  - `-x`：有执行的权限
- 按照文件类型进行判断
  - `-f`：文件存在并且是一个常规的文件
  - `-e`：文件存在
  - `-d`：文件存在并且是一个目录

```shll
if [ -f /root/aaa.txt]
then
	echo "存在"
fi
```

#### 1.5. 流程控制

**if判断**

```shell
if [ 条件判断式 ]
then
	代码
fi
```

```shell
if [ 条件判断式 ]
then
	代码
elif [ 条件判断式 ]
then
	代码
fi
```

> 注意：条件判断式与中括号之间必须有空格

**case语句**

```shell
case $变量名 in
"值1")
代码1
;;
"值2")
代码2
;;
...省略其他分支...
*)
都不匹配执行的代码
;;
esac
```

#### 1.6. 循环

**for循环**

```shell
for 变量 in 值1 值2 值3...
do
代码
done
```

```shell
for(( 初始值; 循环控制条件; 变量变化 ))
do
代码
done
```

**while循环**

```shell
while [ 条件判断式 ]
do
代码
done
```

#### 1.7. 获取输入

`read(选项)(参数)`

**选项**

- `-p`：指定读取值时的提示符
- `-t`：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了

**参数**

- 变量：指定读取值的变量名

#### 1.8. 函数

> Shell编程和其他编程语言一样，有系统函数，也可以自定义函数

##### 1.8.1 系统函数

**basename**

- 功能：返回完整路径最后/的部分，常用于获取文件名
- `basename [pathname] [suffix]`：basename命令会删掉所有的前缀包括最后一个`/`字符，然后将字符串显示出来
- 选项
  - `suffix`为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉

**dirname**

- 功能：返回完整路径最后/的前面的部分，常用于返回路径部分
- `dirname 文件绝对路径`：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）

##### 1.8.2 自定义函数

```shell
[ function ] funname[()]
{
	Action;
	[return int;]
}
```

- 调用直接写函数名：funname [值]

#### 1.9. 定时备份数据库

**需求分析**

1. 每天凌晨2：30备份数据库到`/data/backup/db`
2. 备份开始和备份结束能够给出相应的提示信息
3. 备份后的文件要求以备份时间为文件名，并打包成`.tar.gz`的形式，比如：`2022-12-18_180001.tar.gz`
4. 在备份的同时，检查是否有10天前备份的数据库文件，如果有就删除

### 2、日志管理



### 3、定制自己的Linux



### 4、内核源码&内核升级



### 5、备份与恢复



### 6、可视化管理webmin和bt运维工具



### 7、入侵检测&权限划分&系统优化



### 8、面试题