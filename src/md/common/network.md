---
title: "计算机网络"
order: 2
category:
  - 计算机基础

---

# 计算机网络

## 一、计算机概述

### 1、各种网络 ###

+ 网络(`Network`)由若干**结点(Node)**和连接这些结点的**链路(Link)**组成
+ 多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网(互连网)。因此，互联网是"**网络的网络(Network of Networks)**"
+ **因特网(Internet)**是世界上最大的互连网络【小写`i`的`internet`是通用名词，互连的网络都叫`internet`】

### 2、ISP ###

> 因特网服务提供者(`Internet Service Provider`)

**普通用户如何接入因特网？**

> 通过`ISP`接入因特网。`ISP`可以从因特网管理机构申请到成块的`IP`地址，同时拥有通信线路以及路由器等连网设备，任何机构和个人只要向`ISP`交纳规定的费用，就可以从`ISP`得到所需要的`IP`地址。互联网上的主机都必须有`IP`地址才能通信

![uBXlYmagVoEebrt](http://images.hellocode.top/202211171419748.png)

**基于ISP的三层结构的因特网**

> 层数越小覆盖越多

![2](http://images.hellocode.top/202211171432409.png)

### 3、因特网的组成 ###

+ **边缘部分**：由所有连接在因特网上的**主机**组成，这部分是**用户直接使用**的，用来进行**通信**(传送数据、音频或视频)和资源共享
+ **核心部分**：由**大量网络**和连接这些网络的**路由器**组成。这部分是**为边缘部分提供服务**的(提供连通性和交换)

![3](http://images.hellocode.top/202211171432159.png)

### 4、三种交换方式 ###

#### 4.1. 电路交换(Circuit Switching) ####

**1. 电路交换怎么出现的？**

> 电话问世后，人们发现所有电话之间都两两相连是不现实的。因此可以用一个中间设备将讲话接入，根据需要进行转发

![4](http://images.hellocode.top/202211171433989.png)

**2. 什么是电路交换？**

> 电话交换机接通电话线的方式称为电路交换<br>从通信资源分配角度来看，交换(`Switch`)就是按照某种方式动态地分配传输线路的资源

**3. 电路交换三个步骤**

1. 建立连接(分配通信资源)：例如在使用电路交换打电话前，必须先拨号请求建立连接，当被叫用户听到电话交换机送来的拨号音并拿起电话后，从主叫端到被叫端就建立了一条连接，也就是一条*专用的*物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信中不会被其他用户占用
2. 通话(一直占用通信资源)：分配的资源始终被占用
3. 释放连接(归还通信资源)

![5](http://images.hellocode.top/202211171433988.png)

**优点**

1. 通信时延小：通信线路为通信双方专用的，数据直达
2. 有序传输：通信双方只有一条专用通信线路，数据只在这一线路上传输，不存在失序问题
3. 没有冲突：不同的通信双方拥有不同的信道，不会出现争用物理通道的问题
4. 适用范围广：适用于传输模拟信号，也适用于传输数字信号
5. 实时性强：时延小所以实时性强
6. 控制简单

**缺点**

1. 建立连接时间长
2. 线路独占，适用效率低
3. 灵活性差：只要连接所建立的物理通路中的任何一点出现了故障，就必须重新拨号建立新的连接
4. 难以规格化：不同类型、不同规格、不同速率的终端很难互相进行通信，也难以差错控制

#### 4.2. 分组交换(Packet Switching) ####

+ 发送方：①构建分组 ②发送分组
+ 路由器：①缓存分组 ②转发分组
+ 接收方：①接收分组 ②还原报文

![6](http://images.hellocode.top/202211171433451.png)

**优点**

1. 无需建立连接
2. 线路利用率高
3. 简化存储管理：因为分组大小固定，管理起来就容易一些
4. 加速传输：因为分组是逐个传输，这样前一个交换机的转发操作与后一个交换机的存储操作可同时进行
5. 减少出错率和重复数据量：分组比报文小，因此出错概率也会比较小，即使出错也只需要重传出错的这一小部分即可

**缺点**

1. 引起了转发时延
2. 需要传输额外信息量(分组头部信息)
3. 当分组交换采用数据报服务时，可能会出现失序、丢失、重复分组。分组到达目的结点时，需要重新还原成原始报文，比较麻烦。若分组交换采用虚电路服务，虽然没有分组失序问题，但有呼叫建立，数据传输和虚电路释放三个过程

#### 4.3. 报文交换(Message Switching) ####

> 报文交换与分组交换类似，不过对报文没有限制大小，现如今多使用分组交换。

**优点**

1. 无需建立连接
2. 动态分配线路
3. 提高线路可靠性：如果某条线路出现故障，会重新选择另一条线路
4. 提高线路利用率：通信双方在不同的时间分段占用物理线路
5. 提供多目标服务：一个报文可以同时发送给多个目的地址

**缺点**

1. 引起转发时延：报文在节点交换机上要经历存储转发的过程
2. 需要较大的存储转发空间：因为报文大小没有限制
3. 需要传输额外信息量：有头部等信息

#### 4.4. 三种交换对比 ####

> 纵坐标为时间，分组交换相对报文交换分的更小，可以减少时延，防止过长时间占用线路以及方便排错

![7](http://images.hellocode.top/202211171433967.png)

### 5、计算机网络 ###

#### 5.1. 定义 ####

> 一些互相连接的、自治的计算机的集合

+ **互连**：指计算机之间可以通过有线或无线的方式进行数据通信
+ **自治**：指独立的计算机，它有自己的硬件和软件，可以单独运行使用
+ **集合**：指至少需要两台计算机

#### 5.2. 分类 ####

**按交换技术**：①电路交换网络 ②报文交换网络 ③分组交换网络

**按使用者**：①公用网 ②专用网

**按传输介质**：①有线网络 ②无线网络

**按覆盖范围：** *①广域网WAN ②城域网MAN ③局域网LAN ④个域网PAN*

**按拓扑结构**：①总线型网络 ②星型网络 ③环型网络 ④网状型网络

#### 5.3. 性能指标 ####

> 性能指标可以从不同的方面来度量计算机网络的性能

##### 1. 速率 #####

> 连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率

**常用数据率单位**

![8](http://images.hellocode.top/202211171434485.png)

**比特**

> 计算机中的数据量单位，也是信息论中信息量的单位。一个比特就是二进制数字中的一个`1`或`0`.

**常用数据量**

![9](http://images.hellocode.top/202211171434476.png)

##### 2. 带宽 #####

**带宽在模拟信号系统中的意义**

> 信号所包含的各种不同频率成分所占据的频率范围
>
> 单位：`Hz（kHz，MHz，GHz）`

**带宽在计算机网络中的意义**

> 用来表示网络的**通信线路**所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的"最高数据率"
>
> 单位：`b/s（kb/s，Mb/s，Gb/s，Tb/s）`

**一条通信线路的"频带宽度"越宽，其所传输数据的"最高数据率"也越高**

##### 3. 吞吐量 #####

> 吞吐量表示在**单位时间内通过某个网络(或信道、接口)的数据量。<br>**吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量**受网络的带宽或额定速率的限制**

##### 4. 时延 #####

> 在处理过程中所需要的时间

![10](http://images.hellocode.top/202211171434883.png)

![11](http://images.hellocode.top/202211171434283.png)

##### 5. 时延带宽积 #####

![12](http://images.hellocode.top/202211171434460.png)

##### 6. 往返时间 #####

> 在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互<br>我们有时很需要知道双向交互一次所需要的时间<br>因此，往返时间`RTT(Round-Trip Time)`也是一个重要的性能指标

##### 7. 利用率 #####

> **信道利用率**：用来表示某信道有百分之几的时间是被利用的(有数据通过)<br>**网络利用率**：全网络的信道利用率的加权平均

+ 根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此**信道利用率不是越高越好**

+ 如果令**$D_0$表示网络空闲时的时延**，**D表示网络当前的时延**，那么在适当的假定条件下，可以用下面的简单公式来表示`D`、$D_0$和**利用率U**之间的关系

  																			$D=\dfrac{D_0}{1-U}$

  ![13](http://images.hellocode.top/202211171434876.png)

  当网络利用率`U`到`50%`时，时延急剧增大。

  当网络利用率接近`100%`时，时延趋于无穷大

  但是也不能使信道利用率过低，这回使宝贵的通信资源被浪费

因此一些拥有较大主干网的`ISP`通常会控制它们的信道利用率不超过`50%`。如果超过了，就要准备扩容，增大线路带宽

##### 8. 丢包率 #####

> 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中**丢失的分组数量与总分组数量的比率**<br>具体可分为：接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等

*丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们意识不到丢包*

**分组丢失的两种情况**

+ 分组在传输过程中出现误码，被结点丢弃
+ 分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞

**丢包率反映了网络的拥塞情况**

+ 无拥塞时路径丢包率为`0`
+ 轻度拥塞时路径丢包率为`1%~4%`
+ 严重拥塞时路径丢包率为`5%~15%`

#### 5.4. 体系结构 ####

![1](http://images.hellocode.top/202211171435560.png)

##### 1. 分层的必要性 #####

> 在平常编程时，我们总是喜欢利用不同的类实现不同的功能，最后进行整合实现真正的功能。这样的好处是让结构更加清晰，维护也更加简单。计算机网络分层同理，在计算机网络上实现不同进程的通信需要解决众多问题，分层便于维护与管理

![0](http://images.hellocode.top/202211171442622.png)

##### 2. 分层举例 #####

> 当我们利用浏览器发送网页请求到服务器并发生响应的过程中，数据会怎么变化呢？

![1](http://images.hellocode.top/202211171443424.png)

**浏览器发送**

+ 应用层按照`HTTP协议`的规定构建一个HTTP请求报文(请求要干什么)。应用层将`HTTP请求`的报文交给运输层处理
+ 运输层给`HTTP请求`报文添加一个TCP首部(区分应用进程)，使之成为`TCP报文段`。运输层将`TCP报文段`交给网络层处理
+ 网络层给`TCP报文段`添加一个IP首部(使之可以在互联网上传输)，使之成为`IP数据报`。网络层将`IP数据报`交付给数据链路层处理
+ 数据链路层给`IP数据报`添加一个首部(让其能在一段链路上传输，能被相应主机接收)和一个尾部(让目的主机检查所接收到的帧是否有误码)，使之成为帧。数据链路层将帧交给物理层
+ 物理层将帧看作比特流，如果网络是以太网，它还会在帧上加前导码(让目的主机做好接收帧的准备)。接着将比特流变成相应信号发送到传输媒体

**路由器转发**

+ 物理层收到信号将其变为比特流，去掉前导码后，将其交付给数据链路层(交付的实际是帧)
+ 数据链路层将帧去掉首部和尾部后，将其交付给网络层(交付的实际是IP数据报)
+ 网络层解析`IP数据报`首部，从中提取目的网络地址，然后查找自身路由表，确定转发端口。接着数据链路层封装，物理层再封装，将比特流变成信号发送出去。

**服务器接收**

+ 物理层收到信号将其变为比特流，去掉前导码后，将其交付给数据链路层(交付的实际是帧)
+ 数据链路层收到帧后，去除首部和尾部，将其交付给网络层(交付的实际是IP数据报)
+ 网络层收到`IP数据报`后，去除`IP首部`，将其交付给运输层(交付的实际是TCP报文)
+ 运输层收到`TCP报文`后，从中得知是与哪个端口上的进程通信，去除`TCP头部`后，交付给应用层(交付的实际是HTTP请求报文)
+ 应用层收到`HTTP请求`报文后，将其解析给对应进程，并执行相关操作，返回HTTP响应报文

#### 5.5. 专用术语 ####

##### 1. 实体 #####

> 任何可发送或接收信息的硬件或者软件进程

**对等实体**：收发双方相同层次中的实体

![2](http://images.hellocode.top/202211171443543.png)

##### 2. 协议 #####

> 控制两个对等实体进行逻辑通信(这种通信实际上不存在，只是便于我们考虑问题)的规则的集合

![3](http://images.hellocode.top/202211171443898.png)

**三要素**

+ 语法：定义所交换信息的格式(即报文格式)
+ 语义：定义收发双方所要完成的操作(即收，发任务需要各自定义)
+ 同步：定义收发双方的时序关系(如先建立侦听才可以通信是有先后顺序的)

##### 3. 服务 #####

+ 在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务(也就是说通过协议完成本层的内容后就可以向上提供服务)
+ 要实现本层协议，还需要使用下面一层所提供的服务
+ 协议是"水平的"，服务是**"**垂直的**"**
+ 实体看得见相邻下层所提供的的服务，但是并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是"透明"的`(就像手机为我们提供服务，但是我们并不知道具体是如何实现的)`

服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口(就像Web里的request域，后端前端都能取到)，用于区分不同的服务类型

+ 数据链路层的服务访问点为帧的"类型"字段
+ 网络层的服务访问点位IP数据报首部中的"协议字段"
+ 运输层的服务访问点为"端口号"

**服务原语：**上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语

![4](http://images.hellocode.top/202211171443794.png)

**协议数据单元PDU(横向)**：对等层次之间传送的数据包称为该层的协议数据单元

+ 物理层是比特流；数据链路层是帧；网络层是IP数据报或分组……

**服务数据单元SDU(竖向)**：同一系统内，层与层之间交换的数据报称为服务数据单元

+ 物理层往上送是比特流；数据链路层往下送是帧……

*多个SDU可用合成为一个PDU；一个SDU页可以划分为几个PDU*

## 二、物理层 ##

> 考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流<br>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么

### 1、物理层协议主要任务 ###

+ 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置
+ 电气特性：指明在接口电缆的各条线上出现的电压范围
+ 功能特性：指明某条线上出现的某一电平的电压表示何种意义
+ 过程特性：指明对于不同功能的各种可能事件的出现顺序

### 2、传输媒体 ###

#### 2.1. 导引型传输媒体 ####

> 有摸得到的实物进行传导信号的方式

##### ①同轴电缆 #####

> 电缆各层都是同轴心的，因此称同轴电缆

![5](http://images.hellocode.top/202211171443183.png)

基带同轴电缆(50$\Omega$)：数字传输，过去用于局域网<br>宽带同轴电缆(75$\Omega$)：模拟传输，目前主要用于有线电视

同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体

##### ②双绞线 #####

> 把两根互相绝缘的铜导线并排放在一起，然后按照一定规则绞合起来就构成了双绞线，这是一种古老且常用的传输媒体

**常用绞合线类别、带宽和典型应用**

![6](http://images.hellocode.top/202211171443404.png)

**UTP**

> 无屏蔽双绞线`UTP`电缆

+ 蓝线和蓝白线绞合
+ 橙线和橙白线绞合
+ 绿线和绿白线绞合
+ 棕线和棕白线绞合

作用：①抵御部分来自外界的电磁波干扰   ②减少相邻导线的电磁干扰

**STP**

> 屏蔽双绞线`STP`电缆，其与`UTP`相比增加了金属丝编织的屏蔽层，提高了抗电磁干扰能力

##### ③★光纤 #####

> 光纤很细，因此必须将其做成结实的光缆。一根光缆少则一根光纤，多则可包括数百根

![7](http://images.hellocode.top/202211171443596.png)

**原理**

![8](http://images.hellocode.top/202211171443444.png)

如果全反射一直进行，则光就会沿着光纤一直传输下去。

实际上只要入射角大于某个临界角度就可以发生全反射，因此多条不同角度的光可以在光线里一起传输，这种光纤称作**多模光纤**

![9](http://images.hellocode.top/202211171444586.png)

+ 由于色散(模式、材料、波导色散)，光在多模光纤中传输一定距离后必然产生失真(脉冲展宽)
+ 因此多模光纤只适合近距离传输(建筑物内)
+ 发送光源可使用发光二极管(便宜)；接收检测可用光电二极管

若光纤直径减小到只有一个光的波长，则光纤就像一根波导一样，可使光线一直向前传播，而不会产生多次反射，这样的光纤称作*单模光纤*

![10](http://images.hellocode.top/202211171444352.png)

+ 没有模式色散，在`1.31`微米波长附近，材料色散和波导色散大小相等符号相反，两者正好抵消
+ 单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高
+ 发送光源需要使用激光发生器(贵)；接收检测用激光检波器

**纤芯直径**

+ 多模光纤：`50`微米，`62.5`微米
+ 单模光纤：`9`微米
+ 纤芯外包层：`125`微米

**工作波长**

+ 0.85微米(衰减较大)
+ 1.30微米(衰减较小)
+ 1.55微米(衰减较小)

**优点**

+ 通信容量大(`25000~30000GHz`的带宽)
+ 传输损耗小，远距离传输时更加经济
+ 抗雷电和抗电磁干扰性能好。这在大电流脉冲干扰环境下尤为重要
+ 无串音干扰，保密性好，不易被窃听
+ 体积小，重量轻

**缺点**

+ 割接需要专用设备
+ 光电接口价格较贵

#### 2.2. 非导引型传输媒体 ####

> 传导信号的东西摸不到

![11](http://images.hellocode.top/202211171444747.png)

![12](http://images.hellocode.top/202211171444698.png)

##### ①无线电波 #####

> 低频和中频频段用地面波传播；高频和甚高频靠电离层(地球上方`100~500`千米高空的带电离子层)反射

##### ②★微波 #####

> 微波会穿透电离层进入宇宙，因此其不能通过电离层反射到很远的地方

**地面微波接力通信**

> 微波是**直线传播**的，而地球表面是个曲面，因此传播距离受到限制，一般只有`50KM`左右；如果采用`100`米高的天线塔，则传播距离可增大到`100`公里。<br>为实现远距离通信，必须在一个微波通信信道的两个终端之间建立若干个中继站，**中继站把前一阵送来的信号经过放大后再发送到下一站**

**卫星通信**

> 在地球站之间，利用位于约`36000KM`高空的人造同步地球卫星作为中继器的一种微波接力，其最大特点是通信距离远，传播时延大(约`250~300ms`)。低轨道卫星通信系统也已经正在部署

##### ③红外线 #####

+ 点对点无线传输
+ 直线传播，中间不能有障碍物，传输距离短
+ 传输速率低(`4Mb/s~16Mb/s`)

##### ④可见光 #####

> 即光源作为信号源，前景好，暂时未被大范围应用

### 3、传输方式 ###

#### 3.1. 串行/并行传输 ####

> 串行传输是指数据是`1`个比特`1`个比特依次发送的，发送端与接收端之间只用`1`条数据传输线即可<br>并行传输是指一次发送`n`个比特而不是一个比特，在发送端和接收端之间要有`n`条传输线路

在计算机网络中，数据在传输线路上的传输时串行传输；而计算机内部(如CPU和内存)多使用并行传输

#### 3.2. 同步传输 ####

> 数据块以稳定的比特流形式传输，字节之间没有间隔。接收端在每个比特信号的中间时刻(有区分`0,1`的标志)进行检测，以判别接收到的是比特`0`还是`1`。<br>由于不同设备的时钟频率存在一定差异，不可能完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号的判别错位。因此需要采取方法使双方的时钟保持同步

**收发双方时钟同步方法**

+ 外同步：在收发双方之间加一条单独的时钟信号线
+ 内同步：发送端将时钟同步信号编码到发送数据中一起传输(如曼彻斯特编码)

#### 3.3. 异步传输 ####

> 以字节为独立的传输单位，字节间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步，为此通常传送前要在每个字节前后加上起始位和结束位。

+ 异步是指字节之间异步(字节之间的时间间隔不固定)
+ 字节中的每个比特仍然要同步(各比特的持续时间是相同的)

#### 3.4. 单工/半双工/全双工 ####

+ 单工通信：通信双方只有一个数据传输方向(无线电广播)
+ 半双工通信：通信双方可以相互传输数据，但不能同时进行(对讲机)
+ 全双工通信：通信双方可以同时发送和接收消息(电话)

单工需要一条信道；其他的需要两条(一个方向一条)

### 4、编码与调制 ###

+ 消息(`message`)包括文字、图片、音频和视频
+ 数据是运送消息的实体；计算机中的网卡将比特`1`和`0`变换成相应电信号发送到网线，即信号。
+ 信号是数据的电磁表现，由信源(网卡)发出的原始电信号称为基带信号
+ 基带信号又分为数字基带信号(CPU和内存传输的信号)和模拟基带信号(麦克风收到声音后转变的电信号)

> 信号需要在信道中进行传输，信道可分为数字信道和模拟信道
>
> ![13](http://images.hellocode.top/202211171444229.png)
>
> 如果使用信道复用技术，传输媒体里可以有多个信道
>
> 在不改变信号性质的前提下，仅对基带信号的波形进行变换，称为编码。编码后产生的信号还是数字信号，可以在数字信道中传输
>
> 把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生的信号还是模拟信号，可以在模拟信道中传输

![14](http://images.hellocode.top/202211171444315.png)

#### 4.1. 常用编码

![15](http://images.hellocode.top/202211171444392.png)

##### ①不归零编码 #####

> 正电平代表比特`1`，负电平代表比特`0`。在整个码元时间内，电平不会出现零电平

**这种编码方式如何区分连续几个相同电平呢？**

> 这要求发送方发送和接收方接收严格同步，这就需要额外一根传输线来传输时钟信号。接收方按照时钟节拍逐个接收码元。但是对于计算机网络，多的线不如拿来传输数据，因此由于存在同步问题，**计算机中的数据传输不使用不归零编码**

##### ②归零编码 #####

> **每个码元传输结束后信号都要"归零"**，所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。
>
> 实际上，归零编码相当于把时钟信号用"归零"方式编码在了数据之内，这称为"**自同步**"信号
>
> 归零编码中的大部分**数据带宽**都用来传输"归零"而**浪费**掉了(编码效率低)

##### ③曼彻斯特编码 #####

> 码元的中间时刻既表示时钟，又表示数据。根据**正负跳变来区分比特**

***具体如何根据跳变实现同步？***

> 第一次数据跳变的时间记录下来【即半个码元的时间】，此后每过一个码元的时间就进行检测，根据跳变方向决定数据为`0`还是`1`。

##### ④差分曼彻斯特编码 #####

> ①跳变仅表示时钟	②码元开始处电平是否发生变化表示数据。<br>**比曼彻斯特变化少，更适合较高的传输速率**

#### 4.2. 基本调制方法 ####

![16](http://images.hellocode.top/202211171444769.png)

**如上一个码元对应一个比特，如何能让1个码元包含多个比特呢？**

> 可以使用混合调制。正弦信号$A\sin \omega(x+\dfrac{\varphi}{\omega})$，相位和频率是相关的，因此二者不可同时做修改<br>通常情况下，相位和振幅可以结合起来其一调制，称为**正交振幅调制QAM**

**QAM-16**

+ `12`种相位
+ 每种相位有`1`或`2`种振幅可选
+ 可以调制出`16`种码元(波形)，即`16`个形状可以用`4`个二进制位排列组合表示，所以一个码元可以对应`4比特`
+ 码元与`4`个比特的对应关系要采用**格雷码**【任意两个相邻码元只有一位不同】

![17](http://images.hellocode.top/202211171444520.png)

### 5、信道的极限容量 ###

> 通信质量较差的信道在传输信号的过程中会发生**严重失真**(无法识别原信号)**【码间串扰】**

**失真因素**

+ 码元传输速率
+ 信号传输距离
+ 噪声干扰
+ 传输媒体质量

![18](http://images.hellocode.top/202211171445012.png)

![19](http://images.hellocode.top/202211171445932.png)

+ 在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用**多元制**【更好的调制方法】和努力**提高信道中的信噪比**
+ 自从香农公式发布后，各种新的信号处理和调制方法就不断出现，其目的都是为了**尽可能地接近香农公式给出的传输速率极限**

**例题**

![20](http://images.hellocode.top/202211171445591.png)

![21](http://images.hellocode.top/202211171445075.png)

![22](http://images.hellocode.top/202211171445180.png)

## 三、数据链路层 ##

### 1、概述 ###

**物理层发出去的信号需要通过数据链路层才知道是否到达目的地；才知道比特流的分界线**

+ **链路(Link)**：从一个结点到相邻结点的一段物理线路，中间没有任何其他交换结点
+ **数据链路(Data Link)**：把实现通信协议的硬件和软件加到链路上，就构成了数据链路
+ 数据链路层以**帧**为单位传输和处理数据

#### 1.1. 封装成帧 ####

> 数据链路层为数据加上帧首和帧尾使之成为帧的过程

![1](http://images.hellocode.top/202211171527338.png)

+ 帧头和帧尾中含有重要的控制信息
+ 帧头帧尾的作用之一就是帧定界**(变成比特传输后据此区分每个帧的起始和结束)**
+ 为了提高帧的传输效率，应当使**帧的数据部分长度尽可能大**
+ 考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即**最大传送单元MTU**（`Maximum Transfer Unit`）

透明传输是指**数据链路层对上层交付的传输数据没有任何限制**，就好像数据链路层不存在一样(即**保证接收方接到的数据是完整的数据**)

+ **面向字节**的物理链路使用**字节填充**(或称字符填充)的方法实现**==透明传输==**

  > 帧头帧尾有标志位用来划分一个个帧，如果帧内部恰好也出现了标志位，则在第一次扫描时在标志位前面加一个转义字符帮助区分哪个是真正的帧头。考虑到转义字符也可能在帧内部出现，因此在转义字符前也加转义字符。接收方接到消息后但凡看到转义字符开头就会去掉转义字符并且对其后一个字符不做特殊处理

+ **面向比特的物理链路使用比特填充的方法实现透明传输**

  > **零比特填充**：在发送前，对帧的数据部分进行扫描，每`5`个连续的比特`1`后就插入`1`个比特`0`，防止其与首部尾部的标志位混淆。接收方接收时将每`5`个连续的比特`1`后面的`0`剔除即可

#### 1.2. 差错检测 ####

> 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：`1`可能变成`0`，`0`可能变成`1`。这叫**比特差错**
>
> 在一段时间内，传输错误的比特占所传输比特总数的比率称为**误码率BER**(`Big Error Rate`)
>
> 使用**差错检测码**(如`Mac`帧尾的`FCS`)来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一

##### 奇偶校验 #####

> 在待发送的数据后面添加`1`位奇偶校验位，使整个数据(包括所添加的校验位在内)中"`1`"的个数为奇数(奇校验)或为偶数(偶校验)

**比如发送数据001**

+ 若是**奇校验**，则在数据后添加`0`，使其成为`0001`,`1`的个数为奇数。如果传输过程中发生了`1`位误码，则`1`的个数会变成偶数，据此判断是否发生误码；但是若发生了`2`个误码，`1`的个数依然为奇数，因此检查不出来
+ 若为**偶校验**，则在数据后添加`1`，使其成为`1001`,`1`的个数为偶数，其他情况与奇校验类似

**如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码<br>如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码(漏检)**

##### 循环冗余校验CRC #####

+ 收发双方约定好一个生成多项式`G(x)`

  ![2](http://images.hellocode.top/202211171527623.png)

+ 发送方基于待发送的数据和生成多项式计算出差错检测码**(冗余码)**，将其添加到待传输数据的后面一起传输

+ 接收方通过生成多项式来计算收到的数据是否产生了误码

![3](http://images.hellocode.top/202211171527158.png)

*除法内的相减实际是做异或运算，因此没有小的减不了大的这个说法*

![4](http://images.hellocode.top/202211171527365.png)

![5](http://images.hellocode.top/202211171527949.png)

+ **检错码**只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此**无法纠正错误**。
+ 要想纠正传输中的差错，可以使用冗余信息更多的**纠错码**进行**前向纠错**。但纠错码的开销比较大，**在计算机网络中较少使用**
+ **CRC**有很好的检错能力(**漏检率非常低**)，虽然计算比较复杂，但非常**易于用硬件实现**，因此**被广泛应用于数据链路层**
+ 在计算机网络中通常采用**检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧**，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务

#### 1.3. 可靠传输 ####

> **不可靠传输服务**：仅仅丢弃有误码的帧，其他什么也不做<br>**可靠传输**：想办法实现发送端发送什么，接收端就收到什么

+ 一般情况下，**有线链路**的误码率比较低，为了减小开销，并**不要求数据链路层**向上提供**可靠**传输服务。即使出现了误码，可靠传输的问题由其上层处理
+ **无线链路**易受干扰，误码率比较高，因此**要求数据链路层**必须向上层提供**可靠**传输服务
+ 比特差错只是传输差错中的一种，从整个计算机网络体系结构来看，传输差错还包括**分组丢失**、**分组失序**以及**分组重复**
+ 分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层
+ **可靠传输服务并不仅局限于数据链路层**，其他各层均可选择实现可靠传输
+ 可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求

![6](http://images.hellocode.top/202211171528672.png)

##### ①停止-等待协议SW #####

> 发送方发送数据`DATA`，接收方接收时进行差错检测<br>①如果没有出现误码，则**接收**信息并返回**`ACK`**确认分组给发送方，发送方收到`ACK`后，一次通信结束<br>②如果出现误码，则**丢弃**信息并返回**`NAK`**拒绝分组给发送方，发送方收到`NAK`后，重传`DATA`，直至出现`步骤①`的情况

**如果`DATA`传送过程中丢失了，即接收端一直等`DATA`，发送端一直等`ACK`，造成死锁，如何解决呢？**

> 可以引入超时重传机制。可以在发送端设置一计时器`(大约发送接收的平均时间)`，当发送端在这个时间内没有收到`ACK或NAK`时，就会判断`DATA`丢失，从而再次发送`DATA`，打破死锁

**如果`ACK`发送中丢失了，即接收方收不到`ACK`就将数据重新发送，而数据实际上接收方已经有了，因此重复接收，并返回`ACK`，造成错误，怎么办？**

> 可以对每次发的`DATA`都加上序号，这样接收端就可以判断当前的数据是否有接收过，从而决定其去留

**如果发送端发送`DATA 0`，如果`ACK`由于某些原因使其到达接收端的时间变长了，那么根据超时重传，`DATA 0`会再次发送，而此时`ACK`到达，则发送方会认为这是后一次`DATA 0`的确认分组，于是马上发送`DATA 1`。而第二次发送的`DATA 0`此时返回`ACK`，发送方误以为是`DATA 1`的`ACK`，因此又会发送`DATA2`，而实际上`DATA 1`的是否误码等情况还不知道，因此出现了错误，这种情况怎么办？**

> 可以为`ACK`加上编号。则每个`ACK`的相互作用就不会互串了。【对于数据链路层点对点信道，往返时间比较固定，不会出现确认迟到的情况，因此可以不给确认分组编号】

![7](http://images.hellocode.top/202211171528273.png)

![8](http://images.hellocode.top/202211171528392.png)

![9](http://images.hellocode.top/202211171528164.png)

##### ②回退N帧协议GBN #####

> 相对停止-等待协议多个窗口的概念<br>接收窗口尺寸只能等于`1`，因此**接收方只能按序接收正确到达的数据分组**

![10](http://images.hellocode.top/202211171528829.png)

![11](http://images.hellocode.top/202211171528317.png)

+ **接收端返回`ACK n`表示发送过来的分组x<=n的都收到了**

##### ③选择重传协议SR #####

> 与回退`N`帧相比，接收窗口允许多个，且发送窗口最大情况有所变化

![12](http://images.hellocode.top/202211171528931.png)

![13](http://images.hellocode.top/202211171528146.png)

+ **发送窗口接收到`ACK`帧的部分不会超时重传**

### 2、PPP协议 ###

> 数据链路层协议，用于规定帧格式

![14](http://images.hellocode.top/202211171529476.png)

#### 2.1. 透明传输 ####

##### ①字节填充法 #####

> 面向字节的异步链路采用**插入转义字符**的字节填充法

+ 如`PPP`帧的标志字段取值为`7E(16进制)`，如果数据中出现`7E`则需要在数据前插入**转义字符7D**(`16`进制)，并**将原来的7E减20**(`16`进制)，所以`7E`在数据中最终会变成`7D5E`
+ **如果数据中有转义字符7D怎么办呢？**可以在转义字符`7D`前再加一个转义字符`7D`，并将数据的`7D`减`20(16进制)`，于是转义字符`7D`在数据中最终会变成`7D5D`
+ 数据中出现的每一个`ASCII`码控制字符【**数值小于20(16进制)的字符**】，则在**该字符前插入一个7D，同时将该字符的编码加上20(16进制)**
+ 接收方只需要反变换即可恢复出原来的帧的数据部分

![15](http://images.hellocode.top/202211171529528.png)

##### ②比特填充法 #####

> 面向比特的同步链路采用**插入比特0**的比特填充法

+ **发送方**：对帧的数据部分进行扫描(一般由硬件实现)。只要**发现5个连续的比特1，则立即填充1个比特0**
+ **接收方**：对帧的数据部分进行扫描(一般由硬件实现)。只要**发现5个连续的比特1，就把其后的1个比特0删除**

![16](http://images.hellocode.top/202211171529079.png)

#### 2.2. PPP的差错检测 ####

> 接收方每收到一个`PPP`帧，就进行`CRC`检验(多项式)。若`CRC`检验正确，就收下这个帧；反之就丢弃这个帧(不可靠传输服务)。**检验由尾部的FCS实现**
>
> 用于检验的多项式为$X^{16}+X^{12}+X^5+1$

![17](http://images.hellocode.top/202211171529617.png)

### 3、媒体接入层 ###

> 共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即**媒体接入控制MAC**(`Medium Access Control`)

**复用(Multiplexing)就是通过==一条物理线路同时传输多路用户==的信号。**<br>当网络中传输媒体的传输容量大于多条单一信道的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽

![18](http://images.hellocode.top/202211171529337.png)

#### 3.1. 静态划分信道 ####

##### ①频分复用FDM #####

> 将传输线路的频带资源**划分成多个子频带，形成多个子信道**。各子信道之间留出隔离频带，以免造成子信道间干扰。当多个信号输入一个多路复用器时，这个复用器**将每一个信号调制到不同频率的载波上**，接收端由相应的分用器通过滤波将各路信号分隔开，将合成的复用信号恢复成原始的多路信号

![19](http://images.hellocode.top/202211171529973.png)

##### ②时分复用TDM #####

> 将时间划分为一个个时隙，将带宽资源按照时隙轮流分配给不同的用户，每对用户只在所分配时隙里使用线路传输数据。<br>时分复用技术将时间划分为一段段等长的时分复用帧，**每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙**。每个用户所占的时隙是周期性出现的，其周期就是时分复用帧的长度

![20](http://images.hellocode.top/202211171529571.png)

##### ③波分复用WDM #####

> 波分复用其实就是光的频分复用。经过光调制，分别将光载波变换到不同波长。这些光波经过光复用器就可以在一根光纤中传输。到达终点后用光分用器将不同波长的光进行还原得到信息<br>光信号传输一段距离后会衰减，对衰减的光信号必须进行放大才能继续传输

![21](http://images.hellocode.top/202211171529830.png)

##### ④码分复用CDM #####

> 码分复用`CDM`(最初用于军事通信)是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是**码分多址CDMA**
>
> `CDM`的每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰

在`CDMA`中，每一个比特时间再划分为`m`个短的间隔，称为**码片**。通常`m`的值是`64`或`128`<br>使用`CDMA`的每一个站被指派一个唯一的`m bit`码片序列

1. 一个站如果要发送比特`1`，则发送它自己的`m bit`码片序列
2. 一个站如果要发送比特0，则发送它自己的`m bit`码片序列二进制反码

![22](http://images.hellocode.top/202211171530478.png)

**码片序列挑选原则：**

1. 分配给每个站的**码片序列必须各不相同**，实际常采用伪随机码序列

2. 分配给每个站的**码片序列必须相互正交**(规格化内积为`0`)

   令向量`S`表示站`S`的码片序列，令向量`T`表示其他任何站的码片序列。**$S·T(计算方式为码片序列S和T对应项相乘相加再除以长度)等于0$ 即规格化内积等于0**，此时会有以下四个特征↓。

   $S·T恒等于0；S·\overline T恒等于0；S·S恒等于1；S·\overline S恒等于-1$

![23](http://images.hellocode.top/202211171530323.png)

![24](http://images.hellocode.top/202211171530958.png)

![25](http://images.hellocode.top/202211171530297.png)

习题`2`的`B、C、D`的情况同理↑

![26](http://images.hellocode.top/202211171530341.png)

##### 复用与多址的区别 #####

> **==复用==**是将单一媒体的频带资源划分成很多子信道，这些**子信道之间相互独立，互不干扰**。从媒体的整体频带资源上看，**每个子信道只占用该媒体频带资源的一部分**

> ==**多址**==(更确切地应该称为多点接入)处理的是**动态分配信道给用户**。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久地分配给用户的应用中，多址是不需要的(对于无线广播或电视广播站就是这样)

频分复用`FDM`和时分复用`TDM`可用于多点接入，相应名词是**频分多址FDMA**和**时分多址TDMA**。从某种程度上，**FDMA、TDMA、CDMA可以分别看作是FDM、TDM、CDM的应用**

#### 3.2. 动态接入控制 ####

##### 随机接入 #####

> 多个主机连接到一根总线上，当信息同一时间传送相遇时就会发生碰撞。<br>如何协调各主机的工作，使信息避免碰撞是很重要的

###### 载波监听多址接入/碰撞检测(CSMA/CD)【不用于无线网络】 ######

> `96`比特时间是指发送`96`比特所需要的时间，也称为**帧间最小间隔**。其作用是是接收方可以检测出一个帧的结束，同时也使得其他站点都能有机会平等竞争信道并发送帧

![27](http://images.hellocode.top/202211171530958.png)

![28](http://images.hellocode.top/202211171530217.png)

**争用期(碰撞窗口)**

![29](http://images.hellocode.top/202211171530200.png)

*①为什么$\tau - \frac{\delta}{2}$时刻发送碰撞？*

> 当`D`开始发送的时，`A`已经走了$\tau - \delta$时间，所以剩下路程所需要的时间是$\delta$。<br>又因为`A`和`D`发送速度是相同的，因此对于$\delta时间$的路程，每人只需要走$\dfrac{\delta}{2}时间$就会相遇，即碰撞<br>$碰撞时刻=\tau - \delta +\dfrac{\delta}{2}=\tau -\dfrac{\delta}{2}$

*②为什么$t=\tau$时，D检测到碰撞？*

> 根据上边推论，发现`D`走了$\dfrac{\delta}{2}的时间$路程后就发送了碰撞，此时它开始返回，经过同样的时间可以回到`D`<br>$检测到碰撞时间=\dfrac{\delta}{2}+\dfrac{\delta}{2}=\delta$

*③为什么$2\tau - \delta$时，A检测到碰撞？*

> 与`D`检测到碰撞同理，`A`走了$\tau -\dfrac{\delta}{2}时间$，因此往回走也是这么多时间<br>$A检测到碰撞时间=\tau -\dfrac{\delta}{2}+\tau -\dfrac{\delta}{2}=2\tau - \delta$

+ 主机最多经过$2\tau(即\delta→0)$的时长就可以检测到本次发送是否遭受了碰撞
+ 因此，以太网的端到端往返传播时延$2\tau$称为*争用期*或*碰撞窗口期*
+ 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞
+ 每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但*不会超过总线的端到端往返传播时延，即一个争用期时间*
+ 显然，在以太网中发生帧的主机越多，*端到端往返传播时延越大，发生碰撞的可能性就越大*。因此，共享式以太网不能连接太多的主机，*使用的总线也不能太长*
  + $10Mb/s$以太网把争用期定为$512bit$发送时间，即$51.2\mu s$，因此其总线长度不能超过$5120m$，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过$2500m$

**最小帧长**

*为什么需要规定最小帧长？*

> 假设`A`向`D`发送帧，如果帧很短的话，在$2\tau$内就会将帧发送完毕，帧发送完毕后不会进行碰撞检测，而此时依然有发生碰撞的可能。所以必须保证在$2\tau$时间内帧不会被发送完，在这段时间里能够保持碰撞检测

+ 以太网规定最小帧长为64字节，即`512`比特(`512`比特即争用期)
  + 如果要发送的*数据非常少，那么必须加入一些填充字节*，使帧长不小于`64`字节
+ 以太网的最小帧长保证了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞
  + 如果在争用期没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞
  + 如果在争用期检测到碰撞就立即中止发送，这时已经发送出去的数据一定小于`64`字节，因此*凡长度小于`64`字节的帧都是由于碰撞检测而异常中止的无效帧*

**最大帧长**

> 当帧过长时，其他线路会迟迟得不到资源，同时也可能导致接收方缓冲区溢出，因此帧的最大长度也有规定。

![30](http://images.hellocode.top/202211171530210.png)

**退避算法**

> 当帧发送碰撞后会停止发送，隔一段时间后再次发送，而具体隔多少时间再发送需要根据退避算法得出

![31](http://images.hellocode.top/202211171531745.png)

**极限信道利用率**

+ 各主机发送帧都不会产生碰撞

+ 总线一旦空闲就有某个主机立即发送帧

+ 每帧的发送时延为$T_0$，传播时延为$\tau$，占用信道的时间为$T_0+\tau$
  $$
  极限信道利用率S_{max}=\dfrac{T_0}{T_0+\tau}=\dfrac{1}{1+\dfrac{\tau}{T_0}}\\
  为了令S_{max}尽量大，所以应该让\dfrac{\tau}{T_0}尽量小\\
  即\tau尽量小(以太网端到端距离收到限制)或T_0尽量大(以太网帧尽量长)
  $$

![32](http://images.hellocode.top/202211171531480.png)

###### 载波监听多点接入/碰撞避免(CSMA/CA)【用于无线网络】 ######

> `802.11`无线局域网使用`CSMA/CA`协议，在`CSMA`的基础上**增加了一个碰撞避免CA功能，而不再实现碰撞检测功能**
>
> 由于**不可能避免所有的碰撞，并且无线信道误码率较高**，`802.11`标准还**使用了数据链路层确认机制**(停止-等待协议)来保证数据被正确接收

+ **在无线局域网中，仍然可以使用载波监听多址接入CSMA**，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以避免碰撞

+ **在无线局域网中，不能使用碰撞检测CD**，原因如下：

  + 由于无线信道的传输条件特殊，其信号强度的动态范围非常大，***无线网卡上接收到的信号强度往往会远远小于发送信号的强度***(可能差百万倍)。如果要在无线网卡上实现碰撞检测`CD`，对硬件的要求特别高。

  + 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于**无线电波传播的特殊性**(存在**隐蔽站**的问题)，**进行碰撞检测的意义也不大(如下)**。而有线网络中信号会随着总线到达各个地方，不会出现隐蔽站

    ![33](http://images.hellocode.top/202211171531824.png)

+ `802.11`的`MAC`层标准定义了两种不同的媒体接入控制方式

  + **分布式协调功能DCF**。在`DCF`方式下，没有中心控制站点，每个站点使用`CSMA/CA`协议通过***争用信道来获取发送权***，这是`802.11`定义的默认方式
  + **点协调功能PCF。**`PCF`方式使用集中控制的接入算法(一般在***接入点AP实现集中控制***)，是`802.11`定义的可选方式，在实际中较少使用

**帧间间隔IFS**

> `802.11`标准规定，所有的**站点必须在持续检测到信道空闲一段指定时间后才能发送帧**，这段时间称为帧间间隔`IFS`

*帧间间隔的长短取决于该站点要发送的帧的类型*

+ 高优先级帧需要等待的时间较短，因此可优先获得发送权
+ 低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发送碰撞的机会。

*常用的两种帧间间隔如下*

+ 短帧间间隔SIFS($28\mu m$)。这是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用`SIFS`的帧类型由`ACK`帧、`CTS`帧、由过长的`MAC`帧分片后的数据帧、以及所有回答`AP`探询的帧和在`PCF`方式中接入点`AP`发送出的任何帧
+ DCF帧间间隔DIFS($128\mu s$)。它比短帧间间隔`SIFS`要长得多，在`DCF`方式中用来发送数据帧和管理帧

**工作原理**

![34](http://images.hellocode.top/202211171531860.png)

*①为什么源站检测到信道空闲后，还需要等待DIFS时间才将帧发送呢？*

> 因为其他站此时可能有优先级更高的帧需要发送，因此有`DIFS`时间进行缓冲，若这个时间内没有高优先级的帧要发送，则说明信道是真正的空闲

*②为什么目的站接收到帧后还需要等到SIFS时间才返回ACK确认帧呢？*

> `SIFS`是最短的帧间间隔，用来分割一次对话的各帧，在这个时间里由接收状态转变为发送状态

*③当其他站要发送数据，但是发现此时信道正忙时就会退避一段时间，等信道不忙后再进行操作，接着等待DIFS时间(与①同理)，但为什么等待了DIFS时间后还要退避一段随机时间呢？*

> 因为可能有多个站点在信道忙时都想发送帧，因此它们都会被搁置直至信道不忙，在`DIFS`时间后他们会同时发送，而实际上多个站点同时发送数据会碰撞。因此需要一个随机时间将他们进行错峰发送。

**退避算法**

> 多个站点发送冲突时，各个站点需要退避一段随机时间再进行操作

*以下情况必须使用退避算法*

+ 在发送数据帧之前检测到信道处于忙状态时
+ 在每一次重传一个数据帧时
+ 在每一次成功发送后要连续发送下一个帧时(这是为了避免一个站点长时间占用通道)

*过程*

+ 在执行退避算法时，站点为退避计时器设置一个随机的退避时间
  + 当退避计时器的时间减小到`0`，就开始发送数据
  + 当退避计时器的时间还未减小到`0`时信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过`DIFS`后，继续启动退避计时器
+ 在进行第`i`次退避时，退避时间在时隙编号$\{0,1,..,2^{i+1}-1\}$中随机选择一个，然后乘以基本退避时间(也就是一个时隙的长度)就可以得到随机的退避时间。这样做时为了使不同站点选择相同退避时间的概率减少。当时隙编号达到`255`时(对应第`6`次退避)就不再增加了

![35](http://images.hellocode.top/202211171531018.png)

**信道预约**

> 为了尽可能减少碰撞的概率和降低碰撞的影响，`802.11`标准允许要发送数据的站点对信道进行预约

1. 源站在发送数据帧之前先发送一个短的控制帧，称为请求发生RTS，它包括源地址、目的地址以及这次通信(包括相应的确认帧)所需的持续时间
2. 若目的站正确收到源站发来的`RTS`帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS，它也包括这次通信所需的持续时间`从RTS帧中将此持续时间复制到CTS帧中`。
3. 源站收到`CTS`帧后，再等待一段时间`SIFS`后，就可发送其数据帧
   + 如果RTS帧发送碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧
   + 由于RTS帧和CTS帧很短，发生碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延(因为是局域网)，碰撞的概率很大，且一旦发生碰撞而导致数据帧重发就会浪费很多时间，因此用很小的代价对信道进行预约往往是值得的。`802.11`标准规定了`3`种情况供用户选择
     + 使用`RTS`帧和`CTS`帧
     + 不使用`RTS`帧和`CTS`帧
     + 只有当数据帧的长度超过某一数值时才使用`RTS`帧和`CTS`帧
4. 若目的站正确收到了源站发来的数据帧，在等待时间`SIFS`后，就向源站发送确认帧`ACK`
5. 除源站和目的站以外的其他各站，在收到CTS帧(或数据帧)后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会收到其他站的干扰。

![36](http://images.hellocode.top/202211171531879.png)

**虚拟载波监听**

> 除`RTS`帧和`CTS`帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为`802.11`的虚拟载波监听机制

+ 由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题
+ 如下图，`A`与`C`虽然互相覆盖不到，但是C可收到B发出的关于A的CTS帧，从而得知A需要占用信道的时间。在这段时间里，`C`不发送数据，从而解决隐蔽站带来的碰撞问题

![37](http://images.hellocode.top/202211171531601.png)

### 4、MAC地址、IP地址和ARP协议 ###

#### 4.1. MAC地址 ####

> `MAC`地址是以太网的`MAC`子层所使用的的地址

+ 只有*一条路径的信道不需要地址*，因为没得选
+ 当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则**每个主机都必须有一个唯一的标识，即一个数据链路层地址**
+ 在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于**媒体接入控制MAC(Media Access Control)**，因此这类地址被称为`MAC地址`
  + **MAC地址一般被固化在网卡**(网络适配器)的电可擦可编程只读存储器`EEPROM`中，因此`MAC`地址也被称为==硬件地址==
  + `MAC`地址有时也被称为==物理地址==。但是`MAC`地址不属于物理层而是属于数据链路层
+ 一般情况下，用户主机会包含两个网络适配器：有线局域网适配器(有线网卡)和无线局域网适配器(无线网卡)。每个网络适配器都有一个全球唯一的`MAC`地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的`MAC`地址。综上所述，严格来说，**==MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识==**

##### MAC地址格式 #####

![38](http://images.hellocode.top/202211171531116.png)

![39](http://images.hellocode.top/202211171532678.png)

**单播地址、广播地址与多播地址**

+ **单播MAC地址即明确的目的MAC地址**。将此地址填入帧的目的地址栏中，接收到该帧的主机将此地址与自身`MAC`地址进行匹配，若相同则接收，不同则丢弃
+ **广播MAC地址为`FF-FF-FF-FF-FF-FF`**，将此地址填入帧的目的地址栏中，接收到该帧的主机检索该地址发现是广播地址，因此接收该帧
+ ==**MAC地址中第一字节后4比特为(1,3,5,7,9,B,D,F)时，MAC地址是多播地址**==。将此地址填入帧的目的地址栏中，接收到该帧的主机**将此多播地址与自己多播组列表中的地址进行逐一配对**，如果有匹配的项，则接收，否则丢弃

#### 4.2. IP地址 ####

> `IP`地址是`TCP/IP`体系结构的网际层所使用的的地址

`IP`地址是`Internet`上的主机和路由器所使用的的地址，由两部分信息构成

+ **网络编号**：标识因特网上数以百万计的网络
+ **主机编号**：标识同一网络上不同主机(或路由器各接口)

==MAC地址不具备区分不同网络的功能，而IP地址可以通过网络号做到==

如果只是一个**单独网络**，不接入因特网，则使用**MAC地址就足够了**(这不是一般用户的应用方式)<br>如果主机所在的网络**要接入因特网，则IP地址和MAC地址都需要使用**

**数据包转发过程中IP地址与MAC地址变换情况**

![40](http://images.hellocode.top/202211171532622.png)

+ 数据报转发过程中**源IP地址和目的IP地址保持不变**
+ 数据包转发过程中**源MAC地址和目的MAC地址(由ARP协议获得)逐个链路改变**
+ 路由器上有**路由表，记录了要到目的IP地址，先要走哪些路(即下一跳位置)**。所以`H1`起初只带有目的`IP`地址，查询路由表后路由器指路，从而知道下一步该往哪里走，从而不断转发直至到达目的地。

![41](http://images.hellocode.top/202211171532461.png)

#### 4.3. ARP协议 ####

> 地址解析协议`ARP`属于`TCP/IP`体系结构的网际层，其作用是已知设备所分配到的`IP`地址，使用`ARP`协议可以通过该IP地址获取到设备的`MAC`地址

+ **数据的发送需要经过链路，仅仅知道IP地址是无法在数据链路层实现传输的**，因此我们需要得到`IP`地址与`MAC`地址的对应关系，即地址解析。
+ 每台主机都会有一个**ARP高速缓存表，记录有IP地址与MAC地址的对应关系**
+ 初始`ARP`高速缓存表为空，假设此时`B`知道`C`的`IP`地址，准备发送信息，但是由于不知道`C`的`MAC`地址，因此无法封装数据帧，所以此时会**广播**一个**==ARP请求报文(封装在MAC帧中，目的地址为广播地址`FF-FF-FF-FF-FF-FF`)==**，内容如下：
  + 我的`IP`地址是：`xxx `；我的`MAC`地址是：`XXX`；我想知道`C`主机的`MAC`地址是多少？这个广播帧会被该广播域的所有主机收到
  + `A`主机收到后交由上层处理，发现`B`问的不是他，所以不予理会
  + `C`收到后交由上层处理，发现这个`IP`地址正是自己，因此**首先将B的MAC地址和IP地址的对应关系记录到自己的高速缓存表中**，接着返回给==**ARP响应报文(封装在MAC帧中，目的地址为B的MAC地址)**==，其中包含自己的`MAC`地址
+ **ARP高速缓存条目有静态与动态两种类型**
  + 动态代表是通过广播自动获取的条目，生命周期默认为两分钟
  + 静态是手工设置的条目，不同操作系统下的生命周期不同。
+ **ARP协议只能在一段链路或一个网络上使用**

### 5、集线器与交换机 ###

#### 5.1. 集线器 ####

> 集线器`HUB`的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。

+ **使用集线器的以太网在逻辑上仍是一个总线网**，各站共享总线资源，使用的还是`CSMA/CD`协议
+ 集线器只工作在物理层，它的**每个接口仅简单地转发比特**，不进行碰撞检测(由各站网卡检测)
+ **集线器一般都有少量的容错能力和网络管理功能**。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作
+ 集线器是**半双工模式**，收发不能同时进行，收到帧后会**广播到除本身接口外的各个接口**。

#### 5.2. 交换机 ####

> 交换机是一种**负责转发**信号的网络设备，可以为接入交换机的任意两个网络节点提供**独享的电信号通路**

+ 以太网交换机通常由**多个接口**，每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都**工作在全双工方式**

+ 以太网交换机**具有并行性，能同时连通多对接口，使多对主机能同时通信**，无碰撞(不使用`CSMA/CD`协议)

+ 以太网交换机一般都具有多种速率的接口

+ 以太网交换机工作在数据链路层(也包括物理层)，它收到帧后，**在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧**

+ 以太网交换机是一种即插即用的设备，其**内部的帧交换表是通过自学习算法自动地逐渐建立起来的**

+ 帧的两种转发方式

  + 存储转发
  + 直通交换：采用基于硬件的交叉矩阵(交换时延非常小，但不检查是否有差错)

+ **交换机每个接口是一个独立的碰撞域**

+ ![42](http://images.hellocode.top/202211171532547.png)

  + 此时**交换机未进行任何操作**，`pc1 ping pc4`是可以通的，**说明整个交换机连接的范围是一个广播域**。且`ping`通后，`LSW3`交换机的`MAC表`将`PC1`的`MAC`地址与接口的对应关系以及`PC4`的`MAC`地址与接口的对应关系都记录到`MAC`地址表中==【`ping`的消息发送出去时记录下PC1地址接口相关情况，`ping`成功的消息响应返回给PC1时记录下PC4地址接口的情况】==

    ![43](http://images.hellocode.top/202211171532433.png)

##### 交换机自学习和转发帧流程 #####

![44](http://images.hellocode.top/202211171532178.png)

+ 初始交换机`1`和`2`的`MAC`地址表都为空

+ 此时有以下任务：①`A-->B` ②`B-->A` 

  1. `A`发送给`B`的数据通过端口`1`进入交换机，因此交换机先将`MAC地址A 接口1`==**(表示如果要去MAC地址A，可以走接口1)**==记录到`MAC`表中，同时扫描`MAC`表查看是否有`MAC地址B`对应的接口，发现没有。因此将这个帧从**除来源外的所有端口**发送出去【泛洪】。

     + 交换机`1`的端口`2`发送此帧到主机`C`，主机`C`对比`MAC`地址后发现不是给自己的帧，因此丢弃
     + 交换机`1`的`3`端口发送此帧到主机`B`，主机`B`对比`MAC`地址后发现是给自己的帧，因此收下该帧，交付给高层【注意：此时交换机`MAC`地址表并没有学习新的条目】
     + 交换机`1`的`4`端口发送此帧到交换机`2`的端口`2`，交换机`2`首先将`MAC地址A 接口2`记录到`MAC`地址表中，接着扫描`MAC`表，发现没有找到`MAC地址B`对应的接口，因此将这个帧从除来源外的所有端口发送出去【泛洪】。
     + 同理，接口`1`，`3`，`4`发送出去给主机后经过比对发现不是自己的帧，因此丢弃

  2. `B-->A`时，交换机`1`的`MAC`地址表已经有了`MAC地址A 接口1`这个条目

     + `B`发送给`A`的帧从接口`3`进入交换机，交换机首先将`MAC地址B 接口3`记录到`MAC`地址表中，接着查询`MAC`地址表是否有`MAC地址A`对应的接口，发现接口`1`对应的就是`MAC`地址`A`，因此从接口`1`转发出去
     + 帧通过接口`1`到达主机`A`，主机`A`经过比对后发现这是自己的帧，因此将其接收交付给高层

  3. 此时若有一个与`A`连接在同一总线上的主机`G`向`A`发送帧，过程如何？

     ![45](http://images.hellocode.top/202211171533585.png)

     + `G`向`A`发送帧时，由于`A`与`G`处在同一总线上，因此`G`发送的帧会直接传送到`A`处，`A`进行比对发现这是发送给自己的数据，因此将数据接收
     + 同时数据会跑向交换机`1`的端口`1`，所以交换机`1`会将`MAC地址G 接口1`记录到`MAC`表中，同时扫描`MAC`地址表看看是否有`MAC地址A`对应的接口，发现接口`1`就是。但是刚刚学习到的`MAC地址G`也是来自接口`1`，因此交换机知道接口`1`是来源，没有必要将数据再从这个接口转发出去。

**==MAC地址表中的每条记录都有自己的有效时间，到期自动删除==。这是因为MAC地址与交换机接口的对应关系并不是永久性的**

##### STP生成树协议 #####

> `STP`可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题

**当交换机之间链路较少时，某一条链路发送故障，会导致其中有些主机无法通信，即链路不可靠。<br>**如下图，`A`与`B`之间的链路发送故障后，`H1`便无法与`H2`和`H3`进行通信

![46](http://images.hellocode.top/202211171533084.png)

很容易想到的一个方法是**在B与C之间多拉一条链路**，这样即使A与B之间的链路发送故障，`H1`、`H2`、`H3`之间还是能够相互通信，但是这会带来一些问题。如下，当`H1`发送一个广播帧时，我们针对交换机`B`进行过程分析

![47](http://images.hellocode.top/202211171533086.png)

+ 首先`H1`发送的帧进入交换机，交换机将`MAC地址H1 接口1`记录到`MAC`表中，接着检索`MAC`表，发现没有`MAC地址H2`的接口条目，因此进行泛洪，交换机`A`和`C`都接收到此帧
+ 交换机`A/C`首先将`MAC地址H1 接口1`记录到自身的`MAC`表中，接着检索`MAC`表，发现没有广播帧的接口条目，因此进行泛洪。`A`泛洪的帧会被`H3`、交换机`B`、`C`收到；`C`泛洪的帧会被`H2`、交换机`A`、`B`收到。`H2`与`H3`接收帧后发现是一个广播帧，于是接收并交上层处理
+ 我们针对交换机`B`进行分析
  + 此刻它收到了来自交换机`C`的泛洪，**帧内信息依然是`MAC地址H1 `【源MAC地址】**，首先它会将此条目添加进`MAC`表中，发现原先有`MAC地址H1 接口1`的记录，此时它会认为这条记录已经出现错误，因此更新为`MAC地址H1 接口2`。由于该条目的来源就是接口`2`，所以交换机不会再从接口`2`转发出去，而是在接口`1`、`3`处进行泛洪……
  + 同时`B`也收到来自交换机`A`的泛洪，情况与交换机`C`泛洪类似，于是又将`MAC地址H1 接口2`更新为`MAC地址H1 接口3`……
+ 因此帧会在交换机中不停转发，究其原因是因为网络形成了环路，**网络环路**会带来以下问题
  + **广播风暴**
    + 大量消耗网络资源，使得网络无法正常转发其他数据帧
  + **主机收到重复的广播帧**
    + 大量消耗主机资源
  + **交换机的帧交换表震荡(内容不断更新)**

###### 生成树原理 ######

+ 不论交换机之间采用怎样的物理连接，**交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的(无逻辑环路)**
+ 最终生成树的逻辑拓扑**要确保连通整个网络**
+ **当首次连接交换机或网络物理拓扑发生变化时(有可能是人为改变或故障)，交换机都将进行生成树重新计算**

##### VLAN虚拟局域网 #####

> 一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求，每个`VLAN`就是一个独立的广播域

**为什么需要VLAN？**

> 随着交换式以太网规模的扩大，广播域相应扩大，**而巨大的广播域会带来很多弊端**
>
> 1. 广播风暴
>
>    如数台交换机连接了数台主机，当主机`A`要向主机`B`发送数据帧，此时各交换机的`MAC`表均为空，因此帧每到一个交换机就会进行泛洪，由于网络巨大，因此泛洪的范围也巨大
>
> 2. 难以管理和维护
>
> 3. 潜在的安全风险

###### 交换机端口类型 ######

缺省VLAN ID

> 华为交换机上叫`PVID`，**每个端口有且只有一个PVID**。默认情况下端口的`PVID`都为`1`(即端口属于`VLAN 1`)

**==端口上接收时总希望能够打上标签，发送出去时候总希望能去除标签==**

**①Access端口**

+ `Access`端口一般用于终端设备与交换机之间

  注意：交换机与路由器连接的接口也需要使用`access`接口。这是因为路由器中的消息也不带`VLAN`标签，就像终端一样，保证路由器的数据能够进入交换机领域，数据由路由器进入交换机是会被打上默认标签，接着猜按照交换机间`VLAN`的规则行走。简单理解就是把路由器当作终端

+ 交换机初始端口类型是Access

+ Access端口只能属于一个VLAN

+ `Access`端口的PVID值与端口所属VLAN的ID相同(默认为`1`)

+ `Access`端口接收方法

  + 一般只接收"未打标签"的普通以太网MAC帧。根据接收帧的端口`PVID`值给帧"打标签"，即插入`4`字节的`VLAN`标记字段，字段中的`VID`取值与端口`PVID`取值相等

+ `Access`端口==发送处理方法==

  + 若帧中的VID与端口的PVID相等，则"去标签"并转发该帧；否则不转发

**②Trunk端口**

+ `Trunk`端口一般用于交换机之间或交换机与路由器之间的互连
+ `Trunk`端口可以属于多个`VLAN`
+ 用户可以设置`Trunk`端口的`PVID`值，默认情况下，`Trunk`端口`PVID`值为`1`
+ `Trunk`端口==发送处理方法==
  + 对VID==等于==PVID的帧，"去标签，再转发"
  + 对VID不等于PVID的帧，直接转发
+ `Trunk`端口==接收处理方法==
  + 接收"未打标签"的帧。根据接收帧的端口的PVID给帧"打标签"，即插入`4`字节的`VLAN`标记字段，字段中的`VID`取值与端口的`PVID`取值相等
  + 直接接收"已打标签的帧"

**③Hybrid端口**

+ `Hybrid`端口既可以用于交换机之间或交换机与路由器之间的互连(同`Trunk`端口)，也可用于交换机与用户计算机之间的互连(同`Access`端口)
+ `Hybrid`端口可以属于多个`VLAN`(同`Trunk`端口)
+ 用户可以设置`Hybrid`端口的`PVID`值。默认情况下，Hybrid端口的PVID值为1
+ `Hybrid`端口==发送处理方法==↓
  + 查看帧的VID是否在端口的"去标签"列表中
  + 若存在，则"去标签"后转发
  + 若不存在，则直接转发
+ `Hybrid`端口==接收处理方法==(同`Trunk`)
  + 接收"未打标签"的帧，根据接收帧的端口的`PVID`给帧"打标签"，即插入`4`字节`VLAN`标记字段，字段中的`VID`取值与端口的`PVID`取值相等
  + 接收"已打标签的帧"

**如何分割广播域？**

1. 路由器

   由于路由器属于网络层设备，默认情况下不对广播数据包进行转发，因此自然达到隔离的效果。但是成本较高，局域网内部全靠路由器分割广播域是不现实的

2. VLAN虚拟局域网技术

   默认情况下，交换机下的主机会被划入`VLAN 1`，可以通过设置相关语句为交换机设置`VLAN`，如下是将`PC1`与`PC2`划入`VLAN2`的方法

   ![48](http://images.hellocode.top/202211171533711.png)

  ```java
  LSW3：
  valan batch 2  //在LSW3上创建VLAN2
  interface Ethernet 0/0/1  //进入交换机接口1
  port link-type access  //将此接口类型设置为access
  port default vlan 2   //信息经过此接口时若没有VLAN标签则打上VLAN2标签；若有VLAN标签则检查是							否为VLAN2，若为VLAN2则去除标签并转发；若非VLAN2，则不转发。
  //对接口2的设置同理
  ```

设置完毕后，发现`PC1`不能`ping`通`PC4`，因为此时他们不属于一个同一个广播域，但是可以`ping`通`PC2`，因为`PC1`与`PC2`属于同一个广播域`VLAN 2`

![49](http://images.hellocode.top/202211171533841.png)

###### VLAN实现机制 ######

![50](http://images.hellocode.top/202211171533391.png)

+ `VLAN`标记的**最后12比特**称为**VLAN标识符VID**，它唯一地标志了以太网帧属于哪一个`VLAN`
  + `VID`的取值范围是`0~4095`
  + `0`和`4095`都不用来表示`VLAN`，因此用于表示`VLAN`的**VID的有效范围是1~4094**
+ **802.1Q帧时由交换机来处理的，而不是用户主机来处理的** 
  + 当交换机**收到普通的以太网帧时**，会将其插入`4`字节的VLAN标记转变为`802.1Q`，简称**"打标签"**
  + 当交换机**转发802.1Q帧时**，可能会删除其`4`字节`VLAN`标记转变为普通以太网帧，简称**"去标签"**

## 四、网络层 ##

> 主要任务是实现网络互连，进而实现数据包在各网络之间的传输

### 1、面向连接的虚电路服务 ###

+ 可靠的通信由网络来保证
+ 必须**建立网络层的连接----虚电路VC**(`Virtual Circuit`)
+ 通信双方**沿着已建立的虚电路发送分组**
+ ==目的主机的地址仅在连接建立阶段使用==，之后每个**分组的首部只需携带一条虚电路的编号**(构成虚电路的每一段链路都有一个虚电路编号)。
+ 这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方(无差错按序到达、不丢失、不重复)。
+ **通信结束后，需要释放之前所建立的虚电路**

### 2、无连接的数据报服务 ###

+ **可靠通信应当由用户主机来保证**
+ **不需要建立网络层连接**
+ **每个分组可走不同路径**
+ 每个分组的**首部必须携带目的主机的完整地址**
+ 这种通信方式所传送的**分组可能误码、丢失、重复和失序**
+ 由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉
+ 因特网采用了这种设计思想，也就是**将复杂的网络处理功能置于因特网的边缘(用户主机和其内部的运输层)**，而将相对简单的尽最大努力的分组交付功能置于因特网核心。

### 3、IPv4地址 ###

> `IPv4`地址就是因特网上的**每一台主机(或路由器)的每一个接口**分配一个在全世界范围内是**唯一的32比特的标识符**

#### 3.1. 分类编址 ####

![1](http://images.hellocode.top/202211171550050.png)

+ `A`类地址**网络号第1位固定为0**，网络号后面部分不能全`0`，也不能全`1`，所以**网络号范围是1~126**
+ `B`类地址**网络号前2位固定为10**，网络号后面部分可以全取`0`或`1`，所以**网络号范围是128.0~191.255**
+ `C`类地址**网络号前3位固定为110**，网络后后面部分可以全取`0`或`1`，所以**网络号范围是192.0.0~223.255.255**
+ `D`类地址为多播地址，`IP`地址为**224.0.0.0~239.255.255.255**

![2](http://images.hellocode.top/202211171550056.png)

![3](http://images.hellocode.top/202211171550280.png)

#### 3.2. 划分子网的IPv4地址 ####

**为什么需要划分子网？**

> 比如一个单位有`300`台主机，此时需要申请一个`B`类网络地址，很容易得知，分配出去`300`个`IP`地址后，申请得到的`B`类网络**还剩下很多IP地址**。<br>当单位扩大规模，需要再添加两个子网的时，又要为这两个子网分别申请`B`类地址，这会花费一些不必要的支出，实际上子网`1`申请到的`B`类地址还有很多没用到，**我们希望能够将这些剩余地址应用到其他子网中(节约地址)**。

##### 如何实现子网划分？ #####

**32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号**

+ 子网掩码**使用连续的比特1来对应网络号和子网号(子网号来自原先的一部分主机号)**
+ 子网掩码使用连续的比特`0`来对应主机号
+ 将划分子网的`IPv4`地址与其相应的子网掩码进行**(逻辑与运算)【即掩码是1的部分】**就可得到`IPv4`地址所在子网的网络地址

#### 3.3. 无分类编址的IPv4地址 ####

**为什么需要？**

> 划分子网在一定程度上缓解了因特网发展中遇到的困难，但是**数量巨大的C类网因为其地址空间太小并没有得到充分使用**，而因特网的IP地址仍在加速消耗，**整个IPv4地址空间面临全部耗尽的威胁**

1993年，IETF发布了**无分类域间路由选择CIDR**

+ `CIDR`消除了传统的`A`类、`B`类和`C`类地址，以及划分子网的概念

+ `CIDR`可以更加有效地分配`IPv4`地址空间

+ `CIDR`使用**"斜线记法"**，或称`CIDR`记法。即在`IPv4`地址后面加上斜线"`/`"，**在斜线后面写上网络前缀所占比特数量**

  ![4](http://images.hellocode.top/202211171550242.png)

+ **CIDR实际上是将网络前缀都相同的连续IP地址组成一个"CIDR地址块"**

**路由聚合**

> 如路由器`A`上连接同一网络的多台主机，路由器`B`与`A`相连。若`A`将所有主机的具体`IP`地址都报给`B`，则路由器`B`中会增加多项路由条目。可实际上`B`向`A`中任意一个主机转发数据的时都是走同一个端口，因此我们可以**将这些网络的共同前缀提取出来成为新的网络号，同时将剩余主机号置0放入路由器B中**
>
> 如：`A`连接了`172.1.4.0/25`和`172.1.7.0/24`，则提取公共前缀聚合后变为**172.1.4.0/22**

### 4、IP数据报发送转发过程 ###

> 同一个网络之间的主机可以直接通信，不同网络之间的主机通信需要路由器中转

**源主机如何判断目的主机是否和自己在同一个网络中？**

> 将自身的`IP`地址与子网掩码**相与**得到自身的网络号`1`，再将目的`IP`地址与自身子网掩码相与得到网络号`2`。若两个网络号相等，则说明处在同一个网络

**主机如何知道应该把IP数据报交给哪个路由器进行转发呢？**

> 通过设置默认网关。所谓默认网关，即当路由表中查不到数据时会将数据发往的路由器端口`IP`地址

##### 静态路由配置 #####

**静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表**

+ 这种人工配置方式简单、开销小。但不能及时适应网络状态的变化。**一般只在小规模网络中采用**
+ 可能由于：①配置错误 ②聚合了不存在的网络 ③网络故障 而**出现路由环路错误**
+ ==默认路由为：0.0.0.0/0== 。其**作用是当路由表不知道往哪里转发时，就会往默认路由指定的下一跳位置转发**，根据网络号最长匹配原理，默认路由网络号长度为`0`，因此一定是最后一个被匹配的条目
+ ==特定主机路由：具体主机IP/32==。网络号前缀长度`32`保证了这是第一个被匹配的静态条目

**如何防止错误路由导致IP数据报永久兜圈？**

1. 在`IP`数据报首部**设置生存时间TTL字段**
   + `IP`数据报进入路由器后，`TTL`字段的值减`1`。**若TTL的值不等于0，则被路由器转发，否则被丢弃**
2. 对于聚合后或由于网络故障而不存在的路由条目**设置黑洞路由**
   + 所谓**黑洞路由，即路由器应该丢弃的路由**

### 5、路由选择协议 ###

因特网所采用的的路由选择协议主要特点

+ **自适应**：动态路由选择，能较好地适应网络状态的变化
+ **分布式**：路由器之间交换路由信息
+ **分层次**：将整个因特网划分为许多较小的自治系统`AS`

#### 5.1. 路由信息协议RIP

`RIP`使用**跳数**作为度量**来衡量到达目的网络的距离**

+ 路由器到直连网络的距离定义为`1`
+ 路由器到非直连网络的距离定义为所经过的路由器数`+1`
+ 允许一条路径最多只能包含`15`个路由器。**"距离"等于16时相当于不可达**。因此，`RIP`只适用于小型互联网
+ `RIP`认为**好的路由**就是"距离短"的路由，也就是所**通过路由器数量最少的路由**
+ 当到达同一目的网络有多条"距离相等"的路由时，可以进行等价负载均衡
+ `RIP`包含以下三个要点
  + 仅和相邻路由器交换信息
  + 交换的是各自路由表的信息
  + 周期性交换信息

![5](http://images.hellocode.top/202211171550391.png)

##### RIP存在的问题 #####

> 存在"坏消息传播很慢"的问题，又称为**路由环路(两个路由器相互学习错误路由，造成循环)**或距离无穷计数问题，这是距离向量算法的一个固有问题，可以采取多种措施**减少**出现该问题的概率或减小该问题带来的危害

+ 限制最大路径距离为`15`(`16`表示不可达)
+ 当路由表发生变化时就立即发送更新报文(即"**触发更新**")，而不是周期性发送
+ 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口反方向传送(即**"水平分割""毒性反转"**)

#### 5.2. 开放最短路径优先OSPF ####

> 简单来说就是得到一个带权有向图，以当前路由器为起点，通过迪杰斯特拉算法得到到达某个点的最短路径

+ `OSPF`是**基于链路状态**的，而不像`RIP`那样是基于距离向量的

+ `OSPF`采用`SPF`算法计算路由，而不像`RIP`那样是基于距离向量的

+ `OSPF`不限制网络规模，更新效率高，收敛速度快

+ 链路状态是指本路由器都和哪些路由器相邻，以及相应链路的"代价"

  + **"代价"的意思是费用、距离、时延、带宽等**

+ `OSPF`相邻路由器之间通过交互**问候(Hello)分组**，建立和维护邻居关系

  + `Hello`分组封装在`IP`数据报中，发往组播地址`224.0.0.5`

  + 发送周期为`10`秒

  + `40`秒未收到来自邻居路由器的`Hello`分组，则认为该邻居路由器不可达

    ![6](http://images.hellocode.top/202211171550663.png)

+ 使用`OSPF`的每个路由器都会产生**链路状态通告LSA**，包含以下内容

  + 直连网络的链路状态信息
  + 邻居路由器的链路状态信息

+ `LSA`被封装在**链路状态更新分组LSU**中，**采用洪泛法发送**

+ 使用`OSPF`的每个路由器都有一个**链路状态数据库LSDB**，用于存储`LSA`

+ 通过各路由器洪泛法发送封**装有自己LSA的LSU分组**，各路由器的`LSDB`最终达到一致

+ 使用`OSPF`的各路由器**基于LSDB进行最短路径优先SPF计算**，构建出各种到达其他各路由器的最短路径，即构建各自的路由表

##### OSPF五种分组 #####

1. **问候**(`Hello`)分组

   用来发现和维护邻居路由器的可达性

2. **数据库描述**(**D**atabase **D**escription)分组

   向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息

3. **链路状态请求信息**(**L**ink **S**tate **R**equest)分组

   向邻居路由器请求发送某些链路状态项目的详细信息

4. **链路状态更新**(**L**ink **S**tate **U**pdate)分组

   路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态

5. **链路状态确认**(**L**ink **S**tate **A**cknowledgement)分组

   这是对链路状态更新分组的确认分组

##### OSPF基本工作过程 #####

+ 相邻路由器之间周期性发送**问候分组(Hello)**，以便建立和维护邻居关系
+ 建立邻居关系后，**给邻居路由器发送数据库描述分组(DD)**，==也就是将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器==
+ 收到数据库描述分组后，若发现自己缺少其中某些链路状态项目，则会发送**链路状态请求分组(LSR)**。
+ 对方收到链路状态请求分组后，则会将其所缺少的链路状态项目的详细信息封装在**链路状态更新分组(LSU)**中发送回去
+ 收到链路状态更新分组后，将这些信息添加到自己的链路状态数据库中

##### 邻居关系的建立 #####

> 一条总线上有多台主机，则它们互为邻居，因此每个路由器都要向其他路由器发送问候分组和链路状态更新分组。为了减少所发送分组的数量，则需要用相应方法对邻居关系进行删减

`OSPF`采用选举**指定路由器DR**(`Designated Router`)和**备用的指定路由器BDR**(`Backup Designated Router`)的方法减少邻居数目

+ 所有的非`DR/BDR`只与`DR/BDR`建立邻居关系
+ 非`DR/BDR`之间通过`DR/BDR`交换信息
+ 当`DR`失效时由`BDR`顶上

#### 5.3. 边界网关协议BGP ####

> 尽力寻找一条能够到达目的网络且比较好的路由(不兜圈子)，而并非找最佳路由

![7](http://images.hellocode.top/202211171550504.png)

**内部网关协议IGP(如路由信息协议RIP或最短路径优先OSPF)**

+ 设法使分组在一个自治系统内尽可能有效地从源网络传输到目的网络
+ 无需考虑自治系统外部其他方面的策略

**外部网关协议EGP(如边界网关协议BGP)**

+ 在不同自治系统内，度量路由的"代价"(距离，宽带，费用等)可能不同。因此，对于自治系统之间的路由选择，使用"代价"作为度量来寻找最佳路由是不行的
  + 比如`A`系统路由选择度量是距离，`B`系统是带宽……那么`A`到系统`E`的路由怎样走最好呢？由于没有统一度量，所以不能直接得到最佳路由
+ 自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等)
  + 如中国的数据报尽量要绕开美国的自治系统

##### 工作原理 #####

![8](http://images.hellocode.top/202211171551163.png)

+ `BGP`发言人**交换网络可达性的信息**(要到达某个网络所要经过的一系列自治系统)
+ 当`BGP`发言人互相交换了网络可达性的信息后，各`BGP`发言人就根据所采用的策略从收到的路由信息中**找出到达各自治系统的较好路由**。也就是构造出树形结构(防环路)的自治系统连通图

##### BGP-4的4中报文 #####

1. **OPEN(打开)报文**：用来与相邻的另一个`BGP`发言人建立关系，使通信初始化
2. **UPDATE(更新)报文**：用来通告某一路由的信息，以及列出要撤销的多条路由
3. **KEEPALIVE(保活)报文**：用来周期性地证实邻站的连通性
4. **NOTIFICATION(通知)报文**：用来发送检测到的差错

![9](http://images.hellocode.top/202211171551789.png)

### 6、IPv4数据报首部格式 ###

![10](http://images.hellocode.top/202211171551068.png)

+ **版本**

  占`4`比特，表示`IP`协议版本。通信双方使用的`IP`协议版本必须一致。目前广泛使用的`IP`协议版本为号为`4(IPv4)`

+ **首部长度**

  占`4`比特，表示`IP`数据报首部长度。该字段取值**以4字节为单位**

  **最小十进制取值为5，表示IP数据报首部只有20字节**【`4`字节单位，所以取值`5`对应`20`字节】固定部分

  **最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分**

+ **可选字段**

  长度从`1`到`40`个字节不等。**用来支持排错、测量及安全等措施**

  可选字段增加了`IP`数据报的功能，但这同时也**使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销**。实际上可选字段很少被使用

+ **填充字段**

  确保首部长度为`4`字节长度的整数倍，使用全`0`进行填充

+ **区分服务**

  占`8`比特，利用该字段的不同数值可提供不同等级的服务质量，只有在使用区分服务时，该字段才起作用。一般情况下不使用该字段

+ **总长度**

  占**16比特**，表示`IP`数据报的总长度【首部+数据载荷】，最大取值为十进制`65535`，**以字节为单位**

+ **标识**

  占`16`比特，**属于同一个数据报的各分片数据报应该具有相同的标识【可理解为ID】**

  `IP`软件维持一个计数器，每产生一个数据报，计数器值`+1`，并将此值赋给标识字段

+ **标志**

  占`3`比特，各比特含义如下

  + `DF`位：`1`表示不允许分片，`0`表示允许
  + `MF`位：`1`表示"后面还有分片"，`0`表示"这是最后一个分片"
  + 保留位：必须为`0`

+ **片偏移(必须是整数)**

  占`13`比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少单位

  **片偏移以8个字节为单位**

  ![11](http://images.hellocode.top/202211171551521.png)

+ **生存时间**

  **占8比特**，最初以秒为单位，最大生存周期为`255`秒；路由器转发IP数据报时，将`IP`数据报首部中的该字段值减去`IP`数据报在本路由器上耗费的时间，若不为`0`【说明路由器消耗时间后还活着】就转发，否则丢弃

  **现在以"跳数"为单位，路由器转发IP数据报时，将IP数据报首部中的该字段值减1，若不为0就转发，否则丢弃**【防止兜圈】

+ **协议**

  占`8`比特，指明`IPv4`数据报的数据部分是何种协议数据单元

  ![12](http://images.hellocode.top/202211171551681.png)

+ **首部检验和**

  占**16比特，用来检测首部在传输过程中是否出现差错**，比`CRC`检验码简单，称为因特网检验和

  `IP`数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段【生存时间、标志、片偏移等】的取值可能发生变化

  由于`IP`层本身不提供可靠传输服务，并且计算首部校验和是一项耗时的操作，因此在`IPv6`中，路由器不再计算首部校验和，从而更快转发`IP`数据报

+ **源IP地址和目的IP地址**

  各占**32比特**，用来填写发送该`IP`数据报的源主机`IP`地址和接收该`IP`数据报的目的主机

### 7、网际控制报文ICMP ###

> 为了更有效地转发`IP`数据报和提高交付成功的机会，在网际层使用了网际控制报文协议`ICMP`

+ 主机或路由器使用`ICMP`来发送差错报告报文和询问报文
+ `ICMP`报文被封装在`IP`数据报中发送

##### 回答报文类型 #####

###### 终点不可达

> **当路由器或主机不能交付数据报时，就向源点发送终点不可达报文**。具体可再根据`ICMP`的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络位置、目的主机未知等`13`种错误

###### 源点抑制 ######

> **当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文**，使源点知道应当把数据报发送速率放慢

###### 时间超过 ######

> 当路由器收到一个目的`IP`地址不是自己的`IP`数据报，会将其**生存时间TTL字段**值减`1`。若结果不为`0`，则将该`IP`数据报转发出去；**若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文**
>
> 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文

###### 参数问题 ######

> 当路由器或目的主机收到`IP`数据报后，根据其首部中的检验和字段发现首部在传输过程中**出现了误码，就丢弃该数据报，并向源点发送参数问题报文**

###### 改变路由(重定向) ######

> **路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)**
>
> 如主机`1`的默认路由是`R1`，信息经过`R1`时，`R1`发现最佳路由不是自己，而是`R2`，所以通过`ICMP`告知主机`1`

##### 询问报文类型 #####

###### 回送请求和回答 ######

+ `ICMP`回送请求报文是由主机或路由器向一个特定的目的主机发出的询问
+ 收到此报文的主机必须给源主机或路由器发送`ICMP`回送回答报文
+ 这种询问报文用来测试目的站是否可达及了解其有关状态

##### 时间戳请求和回答 #####

+ `ICMP`时间戳请求报文是请某个主机或路由器回答当前的日期和时间
+ 在`ICMP`时间戳回答报文中有一个`32`比特的字段，其中写入的整数代表从`1900`年`1`月`1`日起到当前时刻一共有多少秒
+ 这种询问报文用来进行时钟同步和测量时间

#### 不发送ICMP的情况 ####

1. 对`ICMP`差错报告报文不再发送`ICMP`差错报告报文
2. 对**第一个分片的数据报片的所有后续数据报片**都不发送`ICMP`差错报告报文
3. 对具有**多播地址的数据报**都不发送`ICMP`差错报告报文
4. 对具有**特殊地址(如127.0.0.0或0.0.0.0)的数据报**不发送`ICMP`差错报告报文

#### ICMP应用举例 ####

##### 分组网间探测PING #####

+ 用来测试主机或路由器间的连通性【`eNSP`的`ping`命令】
+ 应用层直接使用网际层的`ICMP`(没有通过运输层的`TCP`或`UDP`)
+ 使用`ICMP`回送请求和回答报文

##### 跟踪路由tracerouce #####

> 用来测试IP数据报从源主机到达目的主机要经过哪些路由器

`Windows`版本

+ `tracert`命令
+ 应用层直接使用网际层`ICMP`
+ 使用了`ICMP`回送请求和回答报文以及差错报告报文

###### 实现方法 ######

> 由**主机发送出去的数据包中的生存时间字段TTL由1开始逐渐增加**，每个路由器都会返回一个时间超过报文，由此达到跟踪路由器的目的

### 8、虚拟专用网VPN ###

![13](http://images.hellocode.top/202211171551843.png)

> 利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。<br>虚拟专用网中各主机所分配的地址应该是本机构可自由分配的专用地址

![14](http://images.hellocode.top/202211171552012.png)

### 9、网络地址转换NAT ###

> `NAT`能使大量使用**内部专用地址的专用网络用户共享少量外部全球地址**来访问因特网上的主机和资源【为了节省`IPv4`地址】

由于绝大多数的网络应用都是使用运输层协议`TCP`或`UDP`来传送数据，因此可以**利用运输层的端口号和IP地址一起进行转换。**

这样，**用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信**。这种将端口号和`IP`地址一起进行转换的技术叫作**网络地址与端口号转换NAPT**

## 五、运输层 ##

> **物理层、数据链路层以及网络层**它们共同解决了将主机通过异构网络互联起来所面临的的问题，**实现了==主机到主机==的通信**
>
> 但实际上在**计算机网络中进行通信的真正实体是位于通信==两端主机中的进程==**
>
> **如何为运行在不同主机上的应用进程提供直接的通信服务时运输层的任务，==运输层协议又称端到端协议==**

### 1、端口号 ###

> 为了使运行不同操作系统的计算机的应用进程之间能进行网络通信，必须**使用统一的方法对TCP/IP体系的应用进程进行标识，即端口号**。

**为什么不能使用进程标识符PID来区分各进程？**

> 因为因特网上的计算机并不是使用统一的操作系统，**不同的操作系统使用不同格式的进程标识符**

**端口号只具有本地意义**，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，**不同计算机中的相同的端口号是没有联系的**

端口号使用**16比特**表示，取值范围`0~65535`。

+ **熟知端口号：0~1023**，`IANA`把这些端口号指派给了`TCP/IP`体系中最重要的一些应用协议
+ **登记端口号：1024~49151**，为没有熟知端口号的应用程序使用。使用这类端口号必须在`IANA`按照规定的手续登记，以防止重复。如`Microsoft RDP`微软远程桌面使用的端口是`3389`
+ **短暂端口号：49152~65535**，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号。**通信结束后，这个端口号可供其他客户进程以后使用**

![15](http://images.hellocode.top/202211171552825.png)

### 2、复用 ###

+ 发送方的某些应用进程所发送的不同应用报文，**在运输层使用UDP协议进行封装，这是UDP复用；若用TCP封装则称TCP复用**
+ 运输层使用端口号区分不同进程，不管使用何种协议封装的报文，**在网络层都需要使用IP协议封装成IP数据报，这是IP复用**，数据报中协议字段的值用来表名封装的是何种协议数据单元
+ 根据协议字段的值，**将IP数据报封装的协议数据单元上交运输层的过程叫IP分用**
+ 同理，**UDP根据端口号将数据交给应用进程叫做UDP分用；TCP根据端口号将数据交给应用进程叫做TCP分用**

### 3、用户数据报协议UDP ###

+ `UDP`是**无连接**的，随时可向目的主机发送报文，**支持单播、多播和广播**

+ `UDP`收到应用层报文后直接为报文添加`UDP`首部就进行发送，即**面向应用报文**

+ `UDP`数据报**首部仅8字节**

  ![16](http://images.hellocode.top/202211171552745.png)

### 4、传输控制协议TCP ###

+ `TCP`时**面向连接**的。发送数据前需要"三报文握手"建立连接，数据传输结束后需要"四报文挥手"释放连接

+ **仅支持单播**

+ **TCP是面向字节流的**。其将应用进程交付下来的数据块仅仅看作是一连串的字节流，`TCP`将这些字节流编号并存储在缓冲中；接收方一边接收数据，一边将缓冲中的数据交给应用进程。

+ **接收方收到的字节流必须和发送方收到的字节流完全一致**

+ **不会出现传输差错**(误码、丢失、乱序、重复)

+ `TCP`报文段首部最小`20`字节，最大`60`字节

  ![17](http://images.hellocode.top/202211171552862.png)

#### 流量控制 ####

> 一般来说，我们希望数据传输能快一些，但如果发送方把数据发送得过快，接收方就可能来不及接收，这会造成数据的丢失
>
> 流量控制就是**让发送方的发送速率不要太快，要让接收方来得及接收**

**利用滑动窗口实现流量控制**

+ 发送方和接收方窗口保持一致，发送方窗口随着接收方窗口变化而变化(通过确认报文告知发送方)
+ 发送方发送完窗口内数据后需要等到确认报文才会滑动窗口并继续发送，若窗口内的某个值很久没有收到回答报文，则超时重传报文

**若接收方窗口调为0后，一段时间之后又调为200，此时向发送方传递确认报文，可此时报文丢失，则会造成发送方窗口始终为0，接收方以为发送方收到了确认报文而开始等待数据，造成死锁，如何解决？**

> 当发送方窗口大小为`0`时，其隔一段时间就会发送一个`1`字节大小的零窗口探测报文，看看此时接收窗口大小是否进行调整

**若发送的零窗口探测报文也丢失了，会造成新死锁吗？**

> 不会。因为零窗口探测报文也有超时重传机制

#### 拥塞控制 ####

> 在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分**，网络性能就要变坏，这种情况叫做**拥塞**
>
> 若出现拥塞而不进行控制，**整个网络的吞吐量将随输入负荷的增大而下降**

##### 1. 慢开始和拥塞避免 #####

+ 发送方维护一个叫做**拥塞窗口cwnd**的状态变量，**其值取决于网络的拥塞程度，并且动态变化**
  + `拥塞窗口cwnd`的维护原则：**只要网络没有出现拥塞，拥塞窗口就再增大一些(确认报文段窗口大小)，但只要网络出现拥塞，拥塞窗口就减少一些**
  + 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文(发送超时重传)

+ 发送方将拥塞窗口作为**发送窗口swnd**，即`swnd=cwnd`
+ 维护一个**慢开始门限ssthresh**状态变量
  + 当`cwnd < ssthresh`时，使用慢开始算法
  + 当`cwnd > ssthresh`时，停止使用慢开始算法而改用拥塞避免算法
  + 当`cwnd = ssthresh`时，既可使用慢开始算法，也可以使用拥塞避免算法

###### ==慢开始== ######

**拥塞窗口从1开始，根据应答报文大小来扩大拥塞窗口**，如发送方窗口`2`，应答大小`2`，则下次发送大小为`4`

###### ==拥塞避免== ######

**拥塞窗口每次只扩大1**，而不是向慢开始那样根据发送方的返回窗口进行增加。

当窗口增加到一定大小，发送方发送的报文出现了超时重传，则判断网络可能出现了拥塞，此时**将拥塞窗口初始化为1**，同时将**慢开始门限ssthresh设置为发生拥塞时窗口大小的一半**

*"拥塞避免"并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞*

![18](http://images.hellocode.top/202211171552379.png)

##### 2. 快重传和快恢复 #####

快重传是**使发送方尽快进行重传**，而不是等待超时重传计时器超时再重传

+ 要求**接收方**不用等待自己发送数据时才进行捎带确认，而是要**立即发送确认**

+ 即使**收到了失序的报文段(说明有一段丢失了)**也要立即发出**对已收到的报文段的重复确认**

+ **发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传**，而不是等该报文段的超时重传计时器超时再重传

+ 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞。使用快重传可以使整个网络的吞吐量提高约`20%`

  ![19](http://images.hellocode.top/202211171553512.png)

发送方一旦收到`3`个重复确认，就知道现在只是丢失了个别报文段。也是不启动慢开始算法，而执行**快恢复算法**

+ 发送方**将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法**
+ 也有的快恢复实现是把快恢复开始时的拥塞窗口`cwnd`值再增大一些，即等于新的`ssthresh+3`
  + 既然发送方收到`3`个重复的确认，就表明有`3`个数据报文段已经离开了网络
  + 这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中
  + 可见现在网络中不是堆积了报文段而是减少了`3`个报文段。因此可以适当把拥塞窗口扩大些

![20](http://images.hellocode.top/202211171553926.png)

###### 超时重传时间(RTO)选择 ######

> 正常情况下，超时重传时间应该设为略大于往返时间。但是由于各区域的速率可能不一致，因此将超时重传时间设置为一个固定值是行不通的

利用每次测量得到的`RTT`样本，计算**加权平均往返时间$RTT_S$**(平滑的往返时间)

显然，**超时重传时间==RTO==应略大于加权平均往返时间**$RTT_S$

![21](http://images.hellocode.top/202211171553423.png)

**往返时间测量问题**

![22](http://images.hellocode.top/202211171553586.png)

**针对出现超时重传时无法测准往返时间RTT的问题，有以下解决方法**

> 在计算加权平均往返时间$RTT_S$时，只要报文段重传了，就不采用其往返时间`RTT`样本。也就是**出现重传时，不重新计算$RTT_S$，进而超时重传时间RTO也不会重新计算**。
>
> 此方法的漏洞如下：如果报文段时延突然增大很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段，于是重传，造成死锁
>
> 修正方法：**报文段每重传一次，就把超时重传时间RTO增大一些，典型的做法是将RTO的值取为旧RTO的2倍**

#### 可靠传输 ####

[具体实现](https://www.bilibili.com/video/BV1c4411d7jb?p=63)

![23](http://images.hellocode.top/202211171553606.png)

#### 运输连接管理 ####

> `TCP`的运输连接管理就是使运输连接的建立和释放都能正常地进行

![24](http://images.hellocode.top/202211171553523.png)

+ `SYN`为`1`的报文段不能携带数据，但会消耗一个**序列号seq**
+ `ACK=1`代表这是普通确认报文段，**ack=x+1表示这是对报文段序列号seq=x的确认**

![25](http://images.hellocode.top/202211171553540.png)

+ 客户端发起关闭请求，一去一回后进入半关闭状态【客户端不再发送数据，服务端可能还会发】
+ 服务器将自己剩余的数据发送完后也发送一个关闭请求，接着客户端给予回应后服务器关闭，客户机则要等到一段时间后完全关闭(**防止发给服务器的确认报文丢失**)

![26](http://images.hellocode.top/202211171554612.png)

#### 首部格式 ####

![27](http://images.hellocode.top/202211171554814.png)

+ **源端口**：占`16`比特，写入源端口号，用来**标识==发送==该TCP报文段的应用进程**

+ **目的端口**：占`16`比特，写入目的端口号，用来**标识==接收==该TCP报文段的应用进程**

+ **序号**：占`32`比特，取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号就又回到`0`。作用是**指出本TCP报文段数据载荷的第一个字节的序号**

+ **确认标志位ACK**：取值为`1`时确认号字段才有效，为`0`时确认号字段无效

+ **确认号**：占`32`比特，取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号就又回到`0`。可理解为**若确认号=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据**

+ **数据偏移**：占`4`比特，并**以4字节为单位**

  用来指出`TCP`报文段的数据载荷部分的起始处距离`TCP`报文段的起始处。这个字段**实际上是指出TCP报文段的首部长度**

  **首部固定长度为20字节，因此数据偏移字段的最小值$(0101)_2$；首部最大长度为60字节，因此数据偏移字段最大值为$(1111)_2$**

+ **保留字段**：占**6比特**，保留为今后使用，但是目前应置为`0`

+ **窗口**：占**16比特**，以字节为单位。指出**发送本报文段一方的接收窗口**

  窗口值作为接收方让发送方设置其发送窗口的依据，这是**以接收方的接收能力来控制发送方的发送能力**，称为流量控制

+ **检验和**：占**16比特**，检测范围**包括TCP报文段的首部和数据载荷两部分**

  在计算校验和时，要在`TCP`报文段的前面加上`12`字节的伪首部

+ **同步标志位SYN**：在`TCP`连接建立时用来同步序号

+ **终止标志位FIN**：用来释放`TCP`连接

+ **复位标志位RST**：用来复位`TCP`连接

  当`RST=1`时，表明`TCP`连接出现了异常，必须释放连接，然后再重新建立连接；`RST`置`1`还用来拒绝一个非法的报文段或拒绝打开一个`TCP`连接

+ **推送标志位PSH**：接收方的`TCP`收到该**标志位为1的报文段会尽快上交应用进程**，而不必等到接收缓存都填满后再向上交付

+ **紧急标志位URG**：取值**为1**时**紧急指针字段有效**；取值为`0`时紧急指针字段无效。

+ **紧急指针**：占`16`比特，以字节为单位，用来指明紧急数据的长度

  当发送方有紧急数据时，可**将紧急数据插队到发送缓存的最前面**，并立刻封装到一个`TCP`报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据

+ **选项**：增加选项可以增加`TCP`的功能

  + **最大报文段长度MSS选项**：`TCP`报文段数据载荷部分的最大长度
  + **窗口扩大选项**：为了扩大窗口(提高吞吐率)
  + **时间戳选项**：
    + 用来计算往返时间`RTT`
    + 用于处理序号超范围的情况，又称为防止序号绕回`PAWS`
  + **选择确认选项**：实现选择确认功能

+ **填充**：由于选项长度可变，因此**使用填充来保证报文段首部能被4整除**

## 六、应用层 ##

> 解决通过应用进程的交互来实现特定网络应用的问题
>
> 应用层是计算机网络体系结构的**最顶层**，是**设计和建立见算计网络的最终目的**

### 1、客户/服务器方式(C/S) ###

+ **客户/服务器**
  + 客户和服务器是指通信中所涉及的两个应用进程
  + 客户/服务器方式所描述的是进程之间服务和被服务的关系
  + **客户是服务请求方，服务器是服务提供方**
  + **服务器总是处于==运行等待状态==，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址**
+ 基于`C/S`方式的应用服务通常是**服务集中型**的，即应用服务集在网络中比客户计算机少得多的服务器计算机上
  + 由于一台服务器计算机要为多个客户机提供服务，在`C/S`应用中，**常会出现服务器计算机跟不上众多客户机请求的情况**
  + 为此，在`C/S`应用中，常用**计算机群集**(或服务器场)构建一个强大的**虚拟服务器**

### 2、对等方式(P2P方式) ###

![28](http://images.hellocode.top/202211171554570.png)

### 3、动态主机配置协议DHCP ###

> 通过`DHCP`服务器为指定网段主机分配`IP`地址

![29](http://images.hellocode.top/202211171554662.png)

+ `DHCP`客户机首先进行广播寻找`DHCP`服务器("**DHCP发现**"消息)，源地址为本机`0.0.0.0`，目的地址为广播地址`255.255.255.255`
+ `DHCP`服务器收到后，返回"**DHCP提供**"消息，其中包含提供给`DHCP`客户机的`IP`地址和相关配置信息。源地址为`DHCP`服务器地址，目的地址为**广播地址(因为此时目的客户机还没有IP地址)**
+ 客户机可能会收到**多个DHCP提供消息，一般以收到的第一个为准**。此时客户机知道`DHCP`服务器可以给它分配地址，因此发送"**DHCP请求**"报文来请求分配`IP`地址，报文的源地址为`0.0.0.0`，目的地址为`255.255.255.255`
+ `DHCP`收到请求信息后，查看其中**事务ID**是否相符，若不符则丢弃；符合则从地址池中取得一个`IP`地址，并通过`ARP`协议确认此地址未被使用后，将其封装进"**DHCP确认**"信息中，报文源地址为`DHCP`服务器地址，目的地址为广播地址
+ 客户机收到`DHCP`确认信息后，查看其中事务`ID`是否相符，不符则丢弃；符合则**再次使用ARP确认IP地址没有被使用，确认成功后将此IP地址应用(有一定租约)。**

+ **当IP地址租约达到0.5倍时间时**，客户机会再次向`DHCP`服务器发送请求信息，此时`DHCP`服务器会出现以下三种情况
  1. 收到请求后，返回一个**确认报文**，其中有新的`IP`地址租期
  2. 收到请求后，返回**否认报文**，则客户机收到后立刻停止使用IP地址并重新发送"`DHCP`发现"报文
  3. 不响应。则在租期达到**0.875倍**时，`DHCP`客户必须重新发送"**DHCP请求**"报文，继续等待`DHCP`服务器可能做出的反应。若依然无反应，则租用期到后，客户机必须立刻停止使用当前`IP`地址
+ **客户端可随时终止DHCP服务器提供的租用期**，这时只需要向`DHCP`服务器发送`DHCP`释放报文即可。源地址`0.0.0.0`，目的地址`255.255.255.255`

### 4、域名系统DNS ###

> 我们通过输入网址来访问网页，可实际上计算机间的通信是通过IP地址，所以网址的本质上是`IP`地址，将网址与IP地址映射起来就是`DNS`的作用

**因特网是否可以只适用一台DNS服务器？**

> 这种做法不可取。因为因特网的规模很大，如果只有一个服务器，那么一旦其出现故障，整个因特网就会瘫痪
>
> 因此现实中采用**==层次结构的命名树==**作为主机的名字(即域名)，并使用分布式的域名系统`DNS`
>
> **DNS使大多数域名都在本地解析**，仅少量解析需要在因特网上通信，因此系统效率很高。由于`DNS`是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行

![30](http://images.hellocode.top/202211171554348.png)

![31](http://images.hellocode.top/202211171554857.png)

![32](http://images.hellocode.top/202211171554514.png)

![33](http://images.hellocode.top/202211171554936.png)

![34](http://images.hellocode.top/202211171554969.png)

### 5、文件传送协议FTP ###

> 将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即**文件传送**

`FTP`的常见用途是在计算机之间传输文件，尤其是**用于批量传输文件**。`FTP`的另一个常见用途是**让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器**

+ **FTP提供交互式的访问**，运行客户指明文件的类型与格式(如指明是否使用`ASCII`码)，并**允许文件具有存取权限**(如访问文件的用户必须经过授权，并输入有效的口令)
+ **FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件**

![35](http://images.hellocode.top/202211171554244.png)

+ 用于**传送控制命令**的`TCP`连接在**整个会话过程都保持开启状态**
+ 用于**传送数据**的`TCP`连接只会在**有数据传送时开启，数据结束传送后就关闭**

### 6、电子邮件 ###

电子邮件系统的三个主要组成构件：**用户代理，邮件服务器，以及电子邮件所需的协议**

+ **用户代理**是用户与电子邮件系统的接口，又称为**电子邮件客户端软件**
+ **邮件服务器**是电子邮件系统的基础设施。因特网上所有的`ISP`都有邮件服务器，其**功能是发送和接收邮件，同时还要负责维护用户的邮箱**
+ **协议**包括邮件**发送协议**(如`SMTP`)和邮件**读取协议**(如`POP3`，`IMAP`)

![36](http://images.hellocode.top/202211171554848.png)

#### 6.1. 简单邮件传送协议SMTP ####

![37](http://images.hellocode.top/202211171555832.png)

![38](http://images.hellocode.top/202211171555191.png)

#### 6.2. 邮件读取协议 ####

![39](http://images.hellocode.top/202211171555148.png)

#### 6.3. 基于万维网的电子邮件 ####

![40](http://images.hellocode.top/202211171555993.png)

### 7、万维网 ###

> 万维网并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所，**是运行在因特网上的一个分布式应用**
>
> 万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网

浏览器最重要的部分是**渲染引擎，也就是浏览器内核**。负责对网页内容进行解析和显示

+ 不同的浏览器内核对网页内容的解析也有不同，因此同一网页在不同内核的浏览器里显示的效果可能不同

+ 网页编写者需要在不同内核的浏览器中测试网页显示效果

+ 为了方便地访问在世界范围的文档，万维网使用统一资源定位符`URL`来指明因特网上任何种类"资源"的位置

+ `URL`的一般形式由以下四个部分组成

  ![41](http://images.hellocode.top/202211171555311.png)

#### 7.1. 超文本传输协议HTTP ####

> `HTTP`定义了浏览器(即万维网进程)怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器

![42](http://images.hellocode.top/202211171555510.png)

![43](http://images.hellocode.top/202211171555492.png)

##### HTTP请求报文 #####

![44](http://images.hellocode.top/202211171556835.png)

##### HTTP响应报文 #####

![45](http://images.hellocode.top/202211171556220.png)

#### 7.2. Cookie ####

> `Cookie`提供了一种机制使得万维网服务器能够"记住"用户，而无需用户主动提供用户标识信息。也就是说，**Cookie是一种对无状态的HTTP进行状态化的技术**

![46](http://images.hellocode.top/202211171556657.png)

#### 7.3. 万维网缓冲与代理服务器 ####

![47](http://images.hellocode.top/202211171556985.png)

**如果原始服务器中的文档已经修改，但是代理服务器中仍然有缓存，那么主机访问文档时是否会访问到未修改的文档从而发送错误呢？**

> 实际上，原始服务器会为每个响应的对象设定一个**修改时间字段**和一个**有效日期字段**。当请求到达代理服务器时，若文档未过期则直接返回响应报文，否则向原始服务器发送请求。请求头部中有**If-modified-since字段，记录了上次文档的修改时间**，如果代理服务器中文档的修改时间与原始服务器中文档的修改时间一致，说明文档没有发送变化，因此原始服务器返回一个空文档，否则返回新文档

![48](http://images.hellocode.top/202211171556367.png)

### 8、防火墙 ###

> 防火墙主要用于保护一个网络区域免受来自另一个网络区域的网络攻击和网络入侵行为，主要部署在网络边界，对进出网络的访问行为进行**控制**，安全防护是其核心特性，比如在企业网中，在与`Internet`接口处布置防火墙，可以起到过滤病毒、阻止黑客攻击等好处

#### 8.1. 安全领域 ####

> 安全区域`Zone`是一个或多个接口的集合，是防火墙区别路由器的主要特性，防火墙通过安全区域来划分网络，标识报文流动的“路线”，一般来说，当报文在不同的安全区域流动时，才会受到控制。
>
> 在华为防火墙中，一个接口只能加入到一个安全区域

##### 默认安全领域 #####

华为防火墙的默认安全区域：`Trust`、`DMZ`和`Untrust`

| 区域名  | 受信任程度     | 安全级别 | 何时使用                   |
| ------- | -------------- | -------- | -------------------------- |
| Trust   | 高             | 85       | 定义内部用户所在网络       |
| DMZ     | 中等           | 50       | 定义内部服务器所在网络     |
| Untrust | 低             | 5        | 定义Internet等不安全的网络 |
| Local   | 代表防火墙本身 | 100      |                            |

凡是防火墙主动发出的报文均可认为是`Local`区域发出的，凡是需要防火墙响应并处理的报文均可认为是`Local`区域接收。`Local`不能添加接口， 因为防火墙的所有接口都隐含属于`Local`区域

在网络数量较少网络中，使用默认的安全区域就可以满足划分网络的需求，反之，则需要创建新的安全区域。

#### 8.2. 安全域间 ####

安全域间是**两个安全区域的唯一道路**，也可以用来描述流量的传输通道，任意两个安全区域都可构成一个安全域间。如果希望对经过这条通道的流量进行控制，就必须配置安全策略。

报文在两个安全区域之间流动时，报文从低级别的安全区域向高级别的安全区域流动时为入方向`Inbound`，报文从高级别的安全区域向低级别的安全区域流动时为出方向`Outbound`。

通信双方一定会交互报文，即安全区域的两个方向上都有报文的传输，通过设置安全区域，防火墙的安全区域之间有等级明确的域间关系，不同的安全区域代表不同网络，防火墙成为连接各个网络的节点，以此为基础，防火墙可以对各网络之间流动的报文实施管控。

<img src="http://images.hellocode.top/20210102134711525.png" alt="在这里插入图片描述" style="zoom: 67%;" />

**防火墙内不允许定义优先级一样的区域，同等优先级的区域无法识别Inbout、Outbout**

#### 8.3. 三种工作模式 ####

+ **路由模式**：采用路由模式时，可以完成`ACL`包过滤、`NAT`转换等功能，`Trust`与`Untrust`区域间有一台防护墙，防火墙左右接口`IP`不同，需要使用路由表指导报文的转发，此种模式就是路由。
+ **透明模式**：透明模式的防火墙支持`ACL`规则检查，防攻击检查、流量监控等功能，报文在防火墙当中不仅仅像是交换机的二层处理，还会对报文进行高层分析处理，两个区域`IP`属于同一网段，防火墙接口没有配置`IP`，工作成交换机模式。
+ **混合模式**：`Trust`与`Untrust`区域都使用同一网段，两台防火墙，组成主备关系，防火墙工作为路由模式，左右流量是二层转发，上下流量是三层转发。
