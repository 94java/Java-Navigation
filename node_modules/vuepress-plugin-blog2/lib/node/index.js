import{createPage as T,preparePageComponent as N,preparePageData as O,preparePagesComponents as B,preparePagesData as S,preparePagesRoutes as V}from"@vuepress/core";import{watch as j}from"chokidar";import{removeLeadingSlash as P}from"@vuepress/shared";import{Logger as K}from"vuepress-shared/node";const n=new K("vuepress-plugin-blog2"),x=(t,v)=>{const u={};return Object.keys({"/":{},...v.options.locales}).forEach(l=>{u[l]=[]}),v.pages.filter(t).forEach(l=>{u[l.pathLocale].push(l)}),u},A=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,H=(t,v,u,l=!1)=>{const{category:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(M.map(async({key:e,getter:i,sorter:a=()=>-1,path:o="/:key/",layout:y="Layout",frontmatter:d=()=>({}),itemPath:g="/:key/:name/",itemLayout:k="Layout",itemFrontmatter:c=()=>({})},p)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${p}]'`),null;if(typeof i!="function")return n.error(`Invalid 'getter' option in 'category[${p}]', it should be a function!`),null;t.env.isDebug&&n.info(`Generating ${e} category.
`);const _={},$=[],b=typeof g=="function"?g:r=>(g||"").replace(/:key/g,m(e)).replace(/:name/g,m(r));for(const r in u){if(o){const f=`${r}${P(o.replace(/:key/g,m(e)))}`,h=await T(t,{path:f,frontmatter:{...d(r),blog:{type:"category",key:e},layout:y}}),s=t.pages.findIndex(({path:E})=>E===f);s===-1?t.pages.push(h):t.pages[s].key!==h.key&&(t.pages.splice(s,1,h),l&&n.warn(`Overriding existed path ${f}`)),$.push(h.key),_[r]={path:h.path,map:{}}}else _[r]={path:"",map:{}};const{map:w}=_[r],D={};for(const f of u[r]){const h=i(f);for(const s of h){if(!w[s]){const E=b(s);if(E){const U=`${r}${P(E)}`,R=await T(t,{path:`${r}${P(E)}`,frontmatter:{...c(s,r),blog:{type:"category",name:s,key:e},layout:k}}),I=t.pages.findIndex(({path:C})=>C===U);I===-1?t.pages.push(R):t.pages[I].key!==R.key&&(t.pages.splice(I,1,R),l&&n.warn(`Overriding existed path ${U}`)),$.push(R.key),w[s]={path:R.path,keys:[]}}else w[s]={path:"",keys:[]};D[s]=[]}D[s].push(f)}}for(const f in D)w[f].keys=D[f].sort(a).map(({key:h})=>h);if(t.env.isDebug){let f=`Route ${r} in ${e} category:
`;for(const h in w){const{path:s,keys:E}=w[h];f+=`name: ${h}; ${s?`path: ${s}; `:""}items: ${E.length}
`}n.info(f)}}return{key:e,map:_,pageKeys:$}})).then(async e=>{const i={},a=[];return e.filter(o=>o!==null).forEach(({key:o,map:y,pageKeys:d})=>{i[o]=y,a.push(...d)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(i)};
${t.env.isDev?A:""}
`),t.env.isDebug&&n.info("All categories generated."),a})},G=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,L=(t,v,u,l=!1)=>{const{type:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(M.map(async({key:e,sorter:i=()=>-1,filter:a=()=>!0,path:o="/:key/",layout:y="Layout",frontmatter:d=()=>({})},g)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${g}]'`),null;const k={},c=[];t.env.isDebug&&n.info(`Generating ${e} type.
`);for(const p in u){const _=u[p].filter(a).sort(i).map(({key:$})=>$);if(o){const $=`${p}${P(m(o.replace(/:key/g,e)))}`,b=await T(t,{path:$,frontmatter:{...d(p),blog:{type:"type",key:e},layout:y}}),r=t.pages.findIndex(({path:w})=>w===$);r===-1?t.pages.push(b):t.pages[r].key!==b.key&&(t.pages.splice(r,1,b),l&&n.warn(`Overriding existed path ${$}`)),c.push(b.key),k[p]={path:b.path,keys:_},t.env.isDebug&&n.info(`Route ${p} in ${e} type: path: ${b.path}; items: ${_.length}
`)}else k[p]={path:"",keys:_},t.env.isDebug&&n.info(`Route ${p} in ${e} type: items: ${_.length}
`)}return{key:e,map:k,pageKeys:c}})).then(async e=>{const i={},a=[];return e.filter(o=>o!==null).forEach(({key:o,map:y,pageKeys:d})=>{i[o]=y,a.push(...d)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(i)};
${t.env.isDev?G:""}
`),t.env.isDebug&&n.info("All types generated."),a})},J=t=>v=>{const{getInfo:u=()=>({}),filter:l=e=>Boolean(e.filePathRelative)&&!e.frontmatter.home,metaScope:M="_blog"}=t;let m=[];return v.env.isDebug&&n.info(`Options: ${t.toString()}`),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:M}),extendsPage:e=>{l(e)&&(e.routeMeta={...M===""?u(e):{[M]:u(e)},...e.routeMeta})},onInitialized:e=>{const i=x(l,e);return Promise.all([H(e,t,i,!0).then(a=>{m.push(...a)}),L(e,t,i,!0).then(a=>{m.push(...a)})]).then(()=>{e.env.isDebug&&n.info("temp file generated")})},onWatched:(e,i)=>{if("hotReload"in t?t.hotReload:e.env.isDebug){const a=j("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),o=()=>{const y=[],d=x(l,e);return Promise.all([H(e,t,d).then(g=>{y.push(...g)}),L(e,t,d).then(g=>{y.push(...g)})]).then(async()=>{const g=m.filter(c=>!y.includes(c)),k=y.filter(c=>!m.includes(c));k.length&&(e.env.isDebug&&n.info(`New pages detected: ${k.toString()}`),await Promise.all(k.map(async c=>{await N(e,e.pages.find(({key:p})=>p===c)),await O(e,e.pages.find(({key:p})=>p===c))}))),g.length&&(e.env.isDebug&&n.info(`Removing following pages: ${g.toString()}`),g.forEach(c=>{e.pages.splice(e.pages.findIndex(({key:p})=>p===c),1)})),(g.length||k.length)&&(await B(e),await S(e),await V(e)),m=y,e.env.isDebug&&n.info("temp file updated")})};a.on("add",()=>{o()}),a.on("change",()=>{o()}),a.on("unlink",()=>{o()}),i.push(a)}}}};export{J as blogPlugin};
//# sourceMappingURL=index.js.map
