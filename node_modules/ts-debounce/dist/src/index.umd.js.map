{"version":3,"file":"index.umd.js","sources":["../../src/index.ts"],"sourcesContent":["export type Options<Result> = {\n  isImmediate?: boolean;\n  maxWait?: number;\n  callback?: (data: Result) => void;\n};\n\nexport interface DebouncedFunction<\n  Args extends any[],\n  F extends (...args: Args) => any\n> {\n  (this: ThisParameterType<F>, ...args: Args): Promise<ReturnType<F>>;\n  cancel: (reason?: any) => void;\n}\n\ninterface DebouncedPromise<FunctionReturn> {\n  resolve: (result: FunctionReturn) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function debounce<Args extends any[], F extends (...args: Args) => any>(\n  func: F,\n  waitMilliseconds = 50,\n  options: Options<ReturnType<F>> = {}\n): {\n  (this: ThisParameterType<F>, ...args: Parameters<F> & Args): Promise<\n    ReturnType<F>\n  >;\n  cancel: (reason?: any) => void;\n} {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  const isImmediate = options.isImmediate ?? false;\n  const callback = options.callback ?? false;\n  const maxWait = options.maxWait;\n  let lastInvokeTime = Date.now();\n\n  let promises: DebouncedPromise<ReturnType<F>>[] = [];\n\n  function nextInvokeTimeout() {\n    if (maxWait !== undefined) {\n      const timeSinceLastInvocation = Date.now() - lastInvokeTime;\n\n      if (timeSinceLastInvocation + waitMilliseconds >= maxWait) {\n        return maxWait - timeSinceLastInvocation;\n      }\n    }\n\n    return waitMilliseconds;\n  }\n\n  const debouncedFunction = function (\n    this: ThisParameterType<F>,\n    ...args: Parameters<F>\n  ) {\n    const context = this;\n    return new Promise<ReturnType<F>>((resolve, reject) => {\n      const invokeFunction = function () {\n        timeoutId = undefined;\n        lastInvokeTime = Date.now();\n        if (!isImmediate) {\n          const result = func.apply(context, args);\n          callback && callback(result);\n          promises.forEach(({ resolve }) => resolve(result));\n          promises = [];\n        }\n      };\n\n      const shouldCallNow = isImmediate && timeoutId === undefined;\n\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());\n\n      if (shouldCallNow) {\n        const result = func.apply(context, args);\n        callback && callback(result);\n        return resolve(result);\n      }\n      promises.push({ resolve, reject });\n    });\n  };\n\n  debouncedFunction.cancel = function (reason?: any) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    promises.forEach(({ reject }) => reject(reason));\n    promises = [];\n  };\n\n  return debouncedFunction;\n}\n"],"names":["func","waitMilliseconds","options","timeoutId","isImmediate","callback","maxWait","lastInvokeTime","Date","now","promises","nextInvokeTimeout","undefined","timeSinceLastInvocation","debouncedFunction","args","context","this","Promise","resolve","reject","shouldCallNow","clearTimeout","setTimeout","result","apply","forEach","push","cancel","reason"],"mappings":"8MAoBEA,EACAC,EACAC,WAOIC,WARJF,IAAAA,EAAmB,aACnBC,IAAAA,EAAkC,IAQlC,IAAME,WAAcF,EAAQE,gBACtBC,WAAWH,EAAQG,aACnBC,EAAUJ,EAAQI,QACpBC,EAAiBC,KAAKC,MAEtBC,EAA8C,GAElD,SAASC,IACP,QAAgBC,IAAZN,EAAuB,CACzB,IAAMO,EAA0BL,KAAKC,MAAQF,EAE7C,GAAIM,EAA0BZ,GAAoBK,EAChD,OAAOA,EAAUO,EAIrB,OAAOZ,EAGT,IAAMa,EAAoB,eAErBC,2BAEGC,EAAUC,KAChB,WAAWC,QAAuB,SAACC,EAASC,GAC1C,IAWMC,EAAgBjB,QAA6BQ,IAAdT,EAQrC,QANkBS,IAAdT,GACFmB,aAAanB,GAGfA,EAAYoB,WAjBW,WAGrB,GAFApB,OAAYS,EACZL,EAAiBC,KAAKC,OACjBL,EAAa,CAChB,IAAMoB,EAASxB,EAAKyB,MAAMT,EAASD,GACnCV,GAAYA,EAASmB,GACrBd,EAASgB,QAAQ,mBAAiBP,IAAdA,SAAsBK,KAC1Cd,EAAW,KAUwBC,KAEnCU,EAAe,CACjB,IAAMG,EAASxB,EAAKyB,MAAMT,EAASD,GAEnC,OADAV,GAAYA,EAASmB,GACdL,EAAQK,GAEjBd,EAASiB,KAAK,CAAER,QAAAA,EAASC,OAAAA,OAY7B,OARAN,EAAkBc,OAAS,SAAUC,QACjBjB,IAAdT,GACFmB,aAAanB,GAEfO,EAASgB,QAAQ,mBAAgBN,IAAbA,QAAoBS,KACxCnB,EAAW,IAGNI"}